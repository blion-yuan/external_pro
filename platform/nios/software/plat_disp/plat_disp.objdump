
plat_disp.elf:     file format elf32-littlenios2
plat_disp.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00004150

Program Header:
    LOAD off    0x00001020 vaddr 0x00004020 paddr 0x00004020 align 2**12
         filesz 0x00001858 memsz 0x00001858 flags r-x
    LOAD off    0x00002878 vaddr 0x00005878 paddr 0x0000589c align 2**12
         filesz 0x00000024 memsz 0x00000024 flags rw-
    LOAD off    0x000028c0 vaddr 0x000058c0 paddr 0x000058c0 align 2**12
         filesz 0x00000000 memsz 0x00000184 flags rw-
    LOAD off    0x00003000 vaddr 0x00006000 paddr 0x00006000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00006000  00006000  00003000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000130  00004020  00004020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00001344  00004150  00004150  00001150  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000003e4  00005494  00005494  00002494  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00000024  00005878  0000589c  00002878  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000184  000058c0  000058c0  000028c0  2**2
                  ALLOC, SMALL_DATA
  6 .comment      00000023  00000000  00000000  00003020  2**0
                  CONTENTS, READONLY
  7 .debug_aranges 00000368  00000000  00000000  00003048  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   00003131  00000000  00000000  000033b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 0000174d  00000000  00000000  000064e1  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   00001457  00000000  00000000  00007c2e  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  00000628  00000000  00000000  00009088  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00000b11  00000000  00000000  000096b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    000012f2  00000000  00000000  0000a1c1  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_alt_sim_info 00000050  00000000  00000000  0000b4b4  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00000158  00000000  00000000  0000b508  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .thread_model 00000003  00000000  00000000  0000cd63  2**0
                  CONTENTS, READONLY
 17 .cpu          00000008  00000000  00000000  0000cd66  2**0
                  CONTENTS, READONLY
 18 .qsys         00000001  00000000  00000000  0000cd6e  2**0
                  CONTENTS, READONLY
 19 .simulation_enabled 00000001  00000000  00000000  0000cd6f  2**0
                  CONTENTS, READONLY
 20 .sysid_hash   00000004  00000000  00000000  0000cd70  2**0
                  CONTENTS, READONLY
 21 .sysid_base   00000004  00000000  00000000  0000cd74  2**0
                  CONTENTS, READONLY
 22 .sysid_time   00000004  00000000  00000000  0000cd78  2**0
                  CONTENTS, READONLY
 23 .stderr_dev   00000005  00000000  00000000  0000cd7c  2**0
                  CONTENTS, READONLY
 24 .stdin_dev    00000005  00000000  00000000  0000cd81  2**0
                  CONTENTS, READONLY
 25 .stdout_dev   00000005  00000000  00000000  0000cd86  2**0
                  CONTENTS, READONLY
 26 .sopc_system_name 00000009  00000000  00000000  0000cd8b  2**0
                  CONTENTS, READONLY
 27 .quartus_project_dir 0000001d  00000000  00000000  0000cd94  2**0
                  CONTENTS, READONLY
 28 .sopcinfo     00045b6a  00000000  00000000  0000cdb1  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00006000 l    d  .entry	00000000 .entry
00004020 l    d  .exceptions	00000000 .exceptions
00004150 l    d  .text	00000000 .text
00005494 l    d  .rodata	00000000 .rodata
00005878 l    d  .rwdata	00000000 .rwdata
000058c0 l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../plat_disp_bsp//obj/HAL/src/crt0.o
00004188 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_exception_entry.o
00004094 l       .exceptions	00000000 alt_exception_unknown
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 i2c.c
00000000 l    df *ABS*	00000000 oled.c
00000000 l    df *ABS*	00000000 sys_timer.c
00000000 l    df *ABS*	00000000 uart.c
00000000 l    df *ABS*	00000000 hello_world_small.c
00000000 l    df *ABS*	00000000 sys_call.c
000058e4 l     O .bss	00000060 m_cyc_func
00000000 l    df *ABS*	00000000 sys_task.c
000058c5 l     O .bss	00000001 led.1477
00005889 l     O .rwdata	00000001 show_bit
0000588a l     O .rwdata	00000001 num.1497
0000588b l     O .rwdata	00000001 num.1501
000058c6 l     O .bss	00000001 old_car_num.1505
000058c7 l     O .bss	00000001 old_car_speed.1506
00000000 l    df *ABS*	00000000 lib2-divmod.c
00004e44 l     F .text	00000074 udivmodsi4
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
000051f0 l     F .text	0000003c alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 
0000518c g     F .text	0000002c alt_main
00005944 g     O .bss	00000100 alt_irq
00005890 g     O .rwdata	00000004 uart0
0000589c g       *ABS*	00000000 __flash_rwdata_start
00004bcc g     F .text	00000090 disp_sel
00004234 g     F .text	000000c0 i2c_send_byte
00004b54 g     F .text	00000050 cyc_call_poll
000048b0 g     F .text	00000008 get_tick_stamp
0000449c g     F .text	00000124 oled_init
0000497c g     F .text	00000030 uart0_isr
00006000 g     F .entry	0000001c __reset
00004020 g       *ABS*	00000000 __flash_exceptions_start
00006000 g       *ABS*	00000000 __alt_mem_rom
00004adc g     F .text	00000078 cyc_call_chk
000047a0 g     F .text	000000f8 oled_show_num16
000058d4 g     O .bss	00000004 alt_argv
0000d883 g       *ABS*	00000000 _gp
000051b8 g     F .text	00000004 usleep
00004f64 g     F .text	00000008 __udivsi3
00005444 g     F .text	00000050 alt_icache_flush
00004000 g       *ABS*	00000000 __alt_mem_ram
000058c0 g     O .bss	00000004 g_timer_cnt
000058c4 g     O .bss	00000001 g_rx_data
00005a44 g       *ABS*	00000000 __bss_end
00005010 g     F .text	00000068 alt_iic_isr_register
00005348 g     F .text	000000f4 alt_tick
00004ff8 g     F .text	00000018 alt_ic_irq_enabled
00004430 g     F .text	0000006c oled_clr
00005494 g     O .rodata	000003b0 F8X16
00005314 g     F .text	00000034 alt_alarm_stop
000046dc g     F .text	000000c4 data_show
000058cc g     O .bss	00000004 alt_irq_active
000040ec g     F .exceptions	00000064 alt_irq_handler
00004c5c g     F .text	00000068 sure_polling
00004cc4 g     F .text	00000068 speed_polling
00005304 g     F .text	00000004 alt_dcache_flush_all
00004ba4 g     F .text	00000028 led_polling
0000589c g       *ABS*	00000000 __ram_rwdata_end
000048b8 g     F .text	0000005c timer_init
00005878 g     O .rwdata	0000000b code_tab
00005878 g       *ABS*	00000000 __ram_rodata_end
000042f4 g     F .text	0000003c oled_wr_data
00004f6c g     F .text	00000008 __umodsi3
00005a44 g       *ABS*	00000000 end
00006000 g       *ABS*	00000000 __alt_stack_pointer
0000522c g     F .text	00000050 alt_avalon_timer_sc_init
00004914 g     F .text	00000018 get_tim_delta
00005884 g     O .rwdata	00000001 g_car_num
000043b8 g     F .text	00000078 oled_fill
000049ac g     F .text	00000058 uart0_init
00004150 g     F .text	0000003c _start
000058e0 g     O .bss	00000004 _alt_tick_rate
000058dc g     O .bss	00000004 _alt_nticks
000051dc g     F .text	00000014 alt_sys_init
00005878 g       *ABS*	00000000 __ram_rwdata_start
00005494 g       *ABS*	00000000 __ram_rodata_start
00004a98 g     F .text	00000044 cyc_call_cfg
000058c8 g     O .bss	00000001 g_car_speed
0000527c g     F .text	00000088 alt_busy_sleep
00005a44 g       *ABS*	00000000 __alt_stack_base
00004d2c g     F .text	00000064 car_polling
00004898 g     F .text	00000018 system_timer_isr
000041e0 g     F .text	00000054 i2c_stop
000058c0 g       *ABS*	00000000 __bss_start
00004a04 g     F .text	00000094 main
000045c0 g     F .text	0000011c oled_show_string16
0000492c g     F .text	00000050 delay_ms
000058d0 g     O .bss	00000004 alt_envp
00004eb8 g     F .text	00000050 __divsi3
00005494 g       *ABS*	00000000 __flash_rodata_start
000051bc g     F .text	00000020 alt_irq_init
00004d90 g     F .text	000000b4 car_num_polling
000058d8 g     O .bss	00000004 alt_argc
0000436c g     F .text	0000004c oled_set_point
00004020 g       .exceptions	00000000 alt_irq_entry
00005883 g     O .rwdata	00000001 g_rx_bit
00005885 g     O .rwdata	00000004 rx_table
00004020 g       *ABS*	00000000 __ram_exceptions_start
00004f74 g     F .text	00000004 alt_ic_isr_register
0000589c g       *ABS*	00000000 _edata
00005a44 g       *ABS*	00000000 _end
0000418c g     F .text	00000054 i2c_star
00004150 g       *ABS*	00000000 __ram_exceptions_end
00004fb8 g     F .text	00000040 alt_ic_irq_disable
0000543c g     F .text	00000008 altera_nios2_qsys_irq_init
00004f08 g     F .text	0000005c __modsi3
00006000 g       *ABS*	00000000 __alt_data_end
00004020 g     F .exceptions	00000000 alt_exception
0000601c g       .entry	00000000 _exit
00005308 g     F .text	0000000c alt_icache_flush_all
00004330 g     F .text	0000003c oled_wr_cmd
0000588c g     O .rwdata	00000004 alt_priority_mask
00004f78 g     F .text	00000040 alt_ic_irq_enable
00005894 g     O .rwdata	00000008 alt_alarm_list
00005078 g     F .text	00000114 alt_load



Disassembly of section .entry:

00006000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && !defined(ALT_SIM_OPTIMIZE)
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
    6000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
    6004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
    6008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
    600c:	00bffd16 	blt	zero,r2,6004 <__reset+0x4>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
    6010:	00400034 	movhi	at,0
    ori r1, r1, %lo(_start)
    6014:	08505414 	ori	at,at,16720
    jmp r1
    6018:	0800683a 	jmp	at

0000601c <_exit>:
    601c:	00000000 	call	0 <__alt_mem_ram-0x4000>

Disassembly of section .exceptions:

00004020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
    4020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
    4024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
    4028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
    402c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
    4030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
    4034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
    4038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
    403c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
    4040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
    4044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
    4048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
    404c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
    4050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
    4054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
    4058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
    405c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
    4060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
    4064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
    4068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
    406c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
    4070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
    4074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
    4078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
    407c:	10000326 	beq	r2,zero,408c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
    4080:	20000226 	beq	r4,zero,408c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
    4084:	00040ec0 	call	40ec <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
    4088:	00000306 	br	4098 <alt_exception_unknown+0x4>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
    408c:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
    4090:	e8bfff17 	ldw	r2,-4(ea)

00004094 <alt_exception_unknown>:
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
    4094:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
    4098:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
    409c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
    40a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
    40a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
    40a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
    40ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
    40b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
    40b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
    40b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
    40bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
    40c0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
    40c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
    40c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
    40cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
    40d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
    40d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
    40d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
    40dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
    40e0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
    40e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
    40e8:	ef80083a 	eret

000040ec <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
    40ec:	defffe04 	addi	sp,sp,-8
    40f0:	dfc00115 	stw	ra,4(sp)
    40f4:	dc000015 	stw	r16,0(sp)
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
    40f8:	000b313a 	rdctl	r5,ipending
    40fc:	04000034 	movhi	r16,0
    4100:	84165104 	addi	r16,r16,22852
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
    4104:	2880004c 	andi	r2,r5,1

  active = alt_irq_pending ();

  do
  {
    i = 0;
    4108:	0007883a 	mov	r3,zero
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
    410c:	1000051e 	bne	r2,zero,4124 <alt_irq_handler+0x38>
    4110:	00800044 	movi	r2,1
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
    4114:	1085883a 	add	r2,r2,r2
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
    4118:	2888703a 	and	r4,r5,r2
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
      i++;
    411c:	18c00044 	addi	r3,r3,1
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
    4120:	203ffc26 	beq	r4,zero,4114 <alt_irq_handler+0x28>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
    4124:	180690fa 	slli	r3,r3,3
    4128:	80c7883a 	add	r3,r16,r3
    412c:	18800017 	ldw	r2,0(r3)
    4130:	19000117 	ldw	r4,4(r3)
    4134:	103ee83a 	callr	r2
    4138:	000b313a 	rdctl	r5,ipending

    } while (1);

    active = alt_irq_pending ();
    
  } while (active);
    413c:	283ff11e 	bne	r5,zero,4104 <alt_irq_handler+0x18>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
    4140:	dfc00117 	ldw	ra,4(sp)
    4144:	dc000017 	ldw	r16,0(sp)
    4148:	dec00204 	addi	sp,sp,8
    414c:	f800283a 	ret

Disassembly of section .text:

00004150 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
    4150:	06c00034 	movhi	sp,0
    ori sp, sp, %lo(__alt_stack_pointer)
    4154:	ded80014 	ori	sp,sp,24576
    movhi gp, %hi(_gp)
    4158:	06800034 	movhi	gp,0
    ori gp, gp, %lo(_gp)
    415c:	d6b620d4 	ori	gp,gp,55427
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
    4160:	00800034 	movhi	r2,0
    ori r2, r2, %lo(__bss_start)
    4164:	10963014 	ori	r2,r2,22720

    movhi r3, %hi(__bss_end)
    4168:	00c00034 	movhi	r3,0
    ori r3, r3, %lo(__bss_end)
    416c:	18d69114 	ori	r3,r3,23108

    beq r2, r3, 1f
    4170:	10c00326 	beq	r2,r3,4180 <_start+0x30>

0:
    stw zero, (r2)
    4174:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
    4178:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
    417c:	10fffd36 	bltu	r2,r3,4174 <_start+0x24>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
    4180:	00050780 	call	5078 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
    4184:	000518c0 	call	518c <alt_main>

00004188 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
    4188:	003fff06 	br	4188 <alt_after_alt_main>

0000418c <i2c_star>:
#include "../inc/i2c.h"
#include "altera_avalon_pio_regs.h"
#include <unistd.h>

void i2c_star(void)
{
    418c:	defffd04 	addi	sp,sp,-12
    4190:	dc000015 	stw	r16,0(sp)
    4194:	dfc00215 	stw	ra,8(sp)
    4198:	dc400115 	stw	r17,4(sp)
     *SDA      \_____________
     *    __________
     *SCL           \________
     */

	IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,0x03);
    419c:	04240014 	movui	r16,36864
    41a0:	008000c4 	movi	r2,3
    41a4:	80800035 	stwio	r2,0(r16)
	usleep(20);
    41a8:	01000504 	movi	r4,20
    41ac:	00051b80 	call	51b8 <usleep>
	IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,0x01);
    41b0:	00800044 	movi	r2,1
    41b4:	80800035 	stwio	r2,0(r16)
	usleep(10);
    41b8:	04400284 	movi	r17,10
    41bc:	8809883a 	mov	r4,r17
    41c0:	00051b80 	call	51b8 <usleep>
	IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,0x00);
    41c4:	80000035 	stwio	zero,0(r16)
	usleep(10);
    41c8:	8809883a 	mov	r4,r17
}
    41cc:	dfc00217 	ldw	ra,8(sp)
    41d0:	dc400117 	ldw	r17,4(sp)
    41d4:	dc000017 	ldw	r16,0(sp)
    41d8:	dec00304 	addi	sp,sp,12
	IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,0x03);
	usleep(20);
	IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,0x01);
	usleep(10);
	IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,0x00);
	usleep(10);
    41dc:	00051b81 	jmpi	51b8 <usleep>

000041e0 <i2c_stop>:
}

void i2c_stop(void)
{
    41e0:	defffd04 	addi	sp,sp,-12
    41e4:	dc000015 	stw	r16,0(sp)
    41e8:	dfc00215 	stw	ra,8(sp)
    41ec:	dc400115 	stw	r17,4(sp)
    /*               _______
     *SDA __________/
     *          ____________
     *SCL _____/
     */
	IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,0x00);
    41f0:	04240014 	movui	r16,36864
    41f4:	80000035 	stwio	zero,0(r16)
	usleep(10);
    41f8:	04400284 	movi	r17,10
    41fc:	8809883a 	mov	r4,r17
    4200:	00051b80 	call	51b8 <usleep>
	IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,0x01);
    4204:	00800044 	movi	r2,1
    4208:	80800035 	stwio	r2,0(r16)
	usleep(10);
    420c:	8809883a 	mov	r4,r17
    4210:	00051b80 	call	51b8 <usleep>
	IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,0x03);
    4214:	008000c4 	movi	r2,3
    4218:	80800035 	stwio	r2,0(r16)
	usleep(20);
    421c:	01000504 	movi	r4,20
}
    4220:	dfc00217 	ldw	ra,8(sp)
    4224:	dc400117 	ldw	r17,4(sp)
    4228:	dc000017 	ldw	r16,0(sp)
    422c:	dec00304 	addi	sp,sp,12
	IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,0x00);
	usleep(10);
	IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,0x01);
	usleep(10);
	IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,0x03);
	usleep(20);
    4230:	00051b81 	jmpi	51b8 <usleep>

00004234 <i2c_send_byte>:
}

void i2c_send_byte(alt_u8 data)
{
    4234:	defffa04 	addi	sp,sp,-24
    4238:	dcc00315 	stw	r19,12(sp)
    423c:	dc800215 	stw	r18,8(sp)
    4240:	dc000015 	stw	r16,0(sp)
    4244:	dfc00515 	stw	ra,20(sp)
    4248:	dd000415 	stw	r20,16(sp)
    424c:	dc400115 	stw	r17,4(sp)
    4250:	2021883a 	mov	r16,r4
    4254:	04c00204 	movi	r19,8
        else
        {
        	gpio_sta = 0x00;

        }
        IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,gpio_sta);
    4258:	04a40014 	movui	r18,36864

    for(i = 0; i < 8; i++)
    {
        if(data & 0x80)
        {
        	gpio_sta = 0x02;
    425c:	8028d1ba 	srli	r20,r16,6
        else
        {
        	gpio_sta = 0x00;

        }
        IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,gpio_sta);
    4260:	04640014 	movui	r17,36864

    for(i = 0; i < 8; i++)
    {
        if(data & 0x80)
        {
        	gpio_sta = 0x02;
    4264:	a500008c 	andi	r20,r20,2
        else
        {
        	gpio_sta = 0x00;

        }
        IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,gpio_sta);
    4268:	a0803fcc 	andi	r2,r20,255
    426c:	90800035 	stwio	r2,0(r18)
        usleep(10);
    4270:	01000284 	movi	r4,10
    4274:	00051b80 	call	51b8 <usleep>
        gpio_sta = gpio_sta | 0x01;
    4278:	a0800054 	ori	r2,r20,1
        IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,gpio_sta);
    427c:	10803fcc 	andi	r2,r2,255
    4280:	90800035 	stwio	r2,0(r18)
        usleep(20);
    4284:	01000504 	movi	r4,20
    4288:	00051b80 	call	51b8 <usleep>
        gpio_sta = gpio_sta & 0x0e;
        IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,gpio_sta);
    428c:	a500008c 	andi	r20,r20,2
    4290:	95000035 	stwio	r20,0(r18)
        data <<= 1;
        usleep(10);
    4294:	01000284 	movi	r4,10
    4298:	00051b80 	call	51b8 <usleep>
    429c:	9cffffc4 	addi	r19,r19,-1
void i2c_send_byte(alt_u8 data)
{
    alt_u8 i;
    alt_u8 gpio_sta;

    for(i = 0; i < 8; i++)
    42a0:	98803fcc 	andi	r2,r19,255
        gpio_sta = gpio_sta | 0x01;
        IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,gpio_sta);
        usleep(20);
        gpio_sta = gpio_sta & 0x0e;
        IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,gpio_sta);
        data <<= 1;
    42a4:	8421883a 	add	r16,r16,r16
void i2c_send_byte(alt_u8 data)
{
    alt_u8 i;
    alt_u8 gpio_sta;

    for(i = 0; i < 8; i++)
    42a8:	103fec1e 	bne	r2,zero,425c <i2c_send_byte+0x28>
        IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,gpio_sta);
        data <<= 1;
        usleep(10);
    }

    IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,0x02);
    42ac:	04000084 	movi	r16,2
    42b0:	8c000035 	stwio	r16,0(r17)
    usleep(10);
    42b4:	01000284 	movi	r4,10
    42b8:	00051b80 	call	51b8 <usleep>
    IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,0x03);
    42bc:	008000c4 	movi	r2,3
    42c0:	88800035 	stwio	r2,0(r17)
    usleep(20);
    42c4:	01000504 	movi	r4,20
    42c8:	00051b80 	call	51b8 <usleep>
    IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,0x02);
    42cc:	8c000035 	stwio	r16,0(r17)
    usleep(10);
    42d0:	01000284 	movi	r4,10
}
    42d4:	dfc00517 	ldw	ra,20(sp)
    42d8:	dd000417 	ldw	r20,16(sp)
    42dc:	dcc00317 	ldw	r19,12(sp)
    42e0:	dc800217 	ldw	r18,8(sp)
    42e4:	dc400117 	ldw	r17,4(sp)
    42e8:	dc000017 	ldw	r16,0(sp)
    42ec:	dec00604 	addi	sp,sp,24
    IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,0x02);
    usleep(10);
    IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,0x03);
    usleep(20);
    IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,0x02);
    usleep(10);
    42f0:	00051b81 	jmpi	51b8 <usleep>

000042f4 <oled_wr_data>:
    0x10,0x08,0x08,0x08,0xC8,0x38,0x08,0x00,0x20,0x38,0x26,0x21,0x20,0x20,0x18,0x00,//Z 58
};


void oled_wr_data(alt_u8 send_data)
{
    42f4:	defffe04 	addi	sp,sp,-8
    42f8:	dfc00115 	stw	ra,4(sp)
    42fc:	dc000015 	stw	r16,0(sp)
    4300:	2021883a 	mov	r16,r4
	i2c_star();
    4304:	000418c0 	call	418c <i2c_star>
	i2c_send_byte(0x78);
    4308:	01001e04 	movi	r4,120
    430c:	00042340 	call	4234 <i2c_send_byte>
	i2c_send_byte(0x40);			//write data
    4310:	01001004 	movi	r4,64
    4314:	00042340 	call	4234 <i2c_send_byte>
	i2c_send_byte(send_data);
    4318:	81003fcc 	andi	r4,r16,255
    431c:	00042340 	call	4234 <i2c_send_byte>
	i2c_stop();
}
    4320:	dfc00117 	ldw	ra,4(sp)
    4324:	dc000017 	ldw	r16,0(sp)
    4328:	dec00204 	addi	sp,sp,8
{
	i2c_star();
	i2c_send_byte(0x78);
	i2c_send_byte(0x40);			//write data
	i2c_send_byte(send_data);
	i2c_stop();
    432c:	00041e01 	jmpi	41e0 <i2c_stop>

00004330 <oled_wr_cmd>:
}

void oled_wr_cmd(alt_u8 send_cmd)
{
    4330:	defffe04 	addi	sp,sp,-8
    4334:	dfc00115 	stw	ra,4(sp)
    4338:	dc000015 	stw	r16,0(sp)
    433c:	2021883a 	mov	r16,r4
	i2c_star();
    4340:	000418c0 	call	418c <i2c_star>
	i2c_send_byte(0x78);
    4344:	01001e04 	movi	r4,120
    4348:	00042340 	call	4234 <i2c_send_byte>
	i2c_send_byte(0x00);			//write data
    434c:	0009883a 	mov	r4,zero
    4350:	00042340 	call	4234 <i2c_send_byte>
	i2c_send_byte(send_cmd);
    4354:	81003fcc 	andi	r4,r16,255
    4358:	00042340 	call	4234 <i2c_send_byte>
	i2c_stop();
}
    435c:	dfc00117 	ldw	ra,4(sp)
    4360:	dc000017 	ldw	r16,0(sp)
    4364:	dec00204 	addi	sp,sp,8
{
	i2c_star();
	i2c_send_byte(0x78);
	i2c_send_byte(0x00);			//write data
	i2c_send_byte(send_cmd);
	i2c_stop();
    4368:	00041e01 	jmpi	41e0 <i2c_stop>

0000436c <oled_set_point>:
}

void oled_set_point(alt_u8 x, alt_u8 y)
{
    436c:	defffd04 	addi	sp,sp,-12
    4370:	dc000015 	stw	r16,0(sp)
    4374:	2021883a 	mov	r16,r4
	oled_wr_cmd(0xb0+y);
    4378:	293fec04 	addi	r4,r5,-80
    437c:	21003fcc 	andi	r4,r4,255
	i2c_send_byte(send_cmd);
	i2c_stop();
}

void oled_set_point(alt_u8 x, alt_u8 y)
{
    4380:	dfc00215 	stw	ra,8(sp)
    4384:	dc400115 	stw	r17,4(sp)
	oled_wr_cmd(0xb0+y);
    4388:	00043300 	call	4330 <oled_wr_cmd>
	oled_wr_cmd(((x&0xf0)>>4)|0x10);
    438c:	84403fcc 	andi	r17,r16,255
    4390:	8808d13a 	srli	r4,r17,4
    4394:	21000414 	ori	r4,r4,16
    4398:	00043300 	call	4330 <oled_wr_cmd>
	oled_wr_cmd((x&0x0f)|0x01);
    439c:	8100038c 	andi	r4,r16,14
    43a0:	21000054 	ori	r4,r4,1
}
    43a4:	dfc00217 	ldw	ra,8(sp)
    43a8:	dc400117 	ldw	r17,4(sp)
    43ac:	dc000017 	ldw	r16,0(sp)
    43b0:	dec00304 	addi	sp,sp,12

void oled_set_point(alt_u8 x, alt_u8 y)
{
	oled_wr_cmd(0xb0+y);
	oled_wr_cmd(((x&0xf0)>>4)|0x10);
	oled_wr_cmd((x&0x0f)|0x01);
    43b4:	00043301 	jmpi	4330 <oled_wr_cmd>

000043b8 <oled_fill>:
}

void oled_fill(alt_u8 bmp_dat)
{
    43b8:	defffb04 	addi	sp,sp,-20
    43bc:	dcc00315 	stw	r19,12(sp)
    43c0:	dc800215 	stw	r18,8(sp)
    43c4:	dc000015 	stw	r16,0(sp)
    43c8:	dfc00415 	stw	ra,16(sp)
    43cc:	dc400115 	stw	r17,4(sp)
    43d0:	04002c04 	movi	r16,176
		oled_wr_cmd(0xb0+y);
		oled_wr_cmd(0x01);
		oled_wr_cmd(0x10);
		for(x=0;x<128;x++)
		{
			oled_wr_data(bmp_dat);
    43d4:	24c03fcc 	andi	r19,r4,255
}

void oled_fill(alt_u8 bmp_dat)
{
	unsigned char y,x;
	for(y=0;y<8;y++)
    43d8:	04802e04 	movi	r18,184
	{
		oled_wr_cmd(0xb0+y);
    43dc:	8009883a 	mov	r4,r16
    43e0:	00043300 	call	4330 <oled_wr_cmd>
		oled_wr_cmd(0x01);
    43e4:	01000044 	movi	r4,1
    43e8:	00043300 	call	4330 <oled_wr_cmd>
		oled_wr_cmd(0x10);
    43ec:	01000404 	movi	r4,16
    43f0:	00043300 	call	4330 <oled_wr_cmd>
		for(x=0;x<128;x++)
    43f4:	04402044 	movi	r17,129
    43f8:	00000206 	br	4404 <oled_fill+0x4c>
		{
			oled_wr_data(bmp_dat);
    43fc:	9809883a 	mov	r4,r19
    4400:	00042f40 	call	42f4 <oled_wr_data>
    4404:	8c7fffc4 	addi	r17,r17,-1
	for(y=0;y<8;y++)
	{
		oled_wr_cmd(0xb0+y);
		oled_wr_cmd(0x01);
		oled_wr_cmd(0x10);
		for(x=0;x<128;x++)
    4408:	883ffc1e 	bne	r17,zero,43fc <oled_fill+0x44>
    440c:	84000044 	addi	r16,r16,1
}

void oled_fill(alt_u8 bmp_dat)
{
	unsigned char y,x;
	for(y=0;y<8;y++)
    4410:	84bff21e 	bne	r16,r18,43dc <oled_fill+0x24>
		for(x=0;x<128;x++)
		{
			oled_wr_data(bmp_dat);
		}
	}
}
    4414:	dfc00417 	ldw	ra,16(sp)
    4418:	dcc00317 	ldw	r19,12(sp)
    441c:	dc800217 	ldw	r18,8(sp)
    4420:	dc400117 	ldw	r17,4(sp)
    4424:	dc000017 	ldw	r16,0(sp)
    4428:	dec00504 	addi	sp,sp,20
    442c:	f800283a 	ret

00004430 <oled_clr>:

void oled_clr(void)
{
    4430:	defffc04 	addi	sp,sp,-16
    4434:	dc800215 	stw	r18,8(sp)
    4438:	dc000015 	stw	r16,0(sp)
    443c:	dfc00315 	stw	ra,12(sp)
    4440:	dc400115 	stw	r17,4(sp)
    4444:	04002c04 	movi	r16,176
	unsigned char y,x;
	for(y=0;y<8;y++)
    4448:	04802e04 	movi	r18,184
	{
		oled_wr_cmd(0xb0+y);
    444c:	8009883a 	mov	r4,r16
    4450:	00043300 	call	4330 <oled_wr_cmd>
		oled_wr_cmd(0x01);
    4454:	01000044 	movi	r4,1
    4458:	00043300 	call	4330 <oled_wr_cmd>
		oled_wr_cmd(0x10);
    445c:	01000404 	movi	r4,16
    4460:	00043300 	call	4330 <oled_wr_cmd>
		for(x=0;x<128;x++)
    4464:	04402044 	movi	r17,129
    4468:	00000206 	br	4474 <oled_clr+0x44>
		{
			oled_wr_data(0);
    446c:	0009883a 	mov	r4,zero
    4470:	00042f40 	call	42f4 <oled_wr_data>
    4474:	8c7fffc4 	addi	r17,r17,-1
	for(y=0;y<8;y++)
	{
		oled_wr_cmd(0xb0+y);
		oled_wr_cmd(0x01);
		oled_wr_cmd(0x10);
		for(x=0;x<128;x++)
    4478:	883ffc1e 	bne	r17,zero,446c <oled_clr+0x3c>
    447c:	84000044 	addi	r16,r16,1
}

void oled_clr(void)
{
	unsigned char y,x;
	for(y=0;y<8;y++)
    4480:	84bff21e 	bne	r16,r18,444c <oled_clr+0x1c>
		for(x=0;x<128;x++)
		{
			oled_wr_data(0);
		}
	}
}
    4484:	dfc00317 	ldw	ra,12(sp)
    4488:	dc800217 	ldw	r18,8(sp)
    448c:	dc400117 	ldw	r17,4(sp)
    4490:	dc000017 	ldw	r16,0(sp)
    4494:	dec00404 	addi	sp,sp,16
    4498:	f800283a 	ret

0000449c <oled_init>:

void oled_init(void)
{
    449c:	defffd04 	addi	sp,sp,-12
	delay_ms(500);//初始化之前的延时很重要！
    44a0:	01007d04 	movi	r4,500
		}
	}
}

void oled_init(void)
{
    44a4:	dfc00215 	stw	ra,8(sp)
    44a8:	dc400115 	stw	r17,4(sp)
    44ac:	dc000015 	stw	r16,0(sp)
	delay_ms(500);//初始化之前的延时很重要！
    44b0:	000492c0 	call	492c <delay_ms>
	oled_wr_cmd(0xae);//--turn off oled panel
    44b4:	01002b84 	movi	r4,174
    44b8:	00043300 	call	4330 <oled_wr_cmd>
	oled_wr_cmd(0x00);//---set low column address
    44bc:	0009883a 	mov	r4,zero
    44c0:	00043300 	call	4330 <oled_wr_cmd>
	oled_wr_cmd(0x10);//---set high column address
    44c4:	01000404 	movi	r4,16
    44c8:	00043300 	call	4330 <oled_wr_cmd>
	oled_wr_cmd(0x40);//--set start line address  Set Mapping RAM Display Start Line (0x00~0x3F)
    44cc:	04401004 	movi	r17,64
    44d0:	8809883a 	mov	r4,r17
    44d4:	00043300 	call	4330 <oled_wr_cmd>
	oled_wr_cmd(0x81);//--set contrast control register
    44d8:	01002044 	movi	r4,129
    44dc:	00043300 	call	4330 <oled_wr_cmd>
	oled_wr_cmd(0xff); // Set SEG Output Current Brightness
    44e0:	01003fc4 	movi	r4,255
    44e4:	00043300 	call	4330 <oled_wr_cmd>
	oled_wr_cmd(0xa1);//--Set SEG/Column Mapping     0xa0左右反置 0xa1正常
    44e8:	01002844 	movi	r4,161
    44ec:	00043300 	call	4330 <oled_wr_cmd>
	oled_wr_cmd(0xc8);//Set COM/Row Scan Direction   0xc0上下反置 0xc8正常
    44f0:	01003204 	movi	r4,200
    44f4:	00043300 	call	4330 <oled_wr_cmd>
	oled_wr_cmd(0xa6);//--set normal display
    44f8:	04002984 	movi	r16,166
    44fc:	8009883a 	mov	r4,r16
    4500:	00043300 	call	4330 <oled_wr_cmd>
	oled_wr_cmd(0xa8);//--set multiplex ratio(1 to 64)
    4504:	01002a04 	movi	r4,168
    4508:	00043300 	call	4330 <oled_wr_cmd>
	oled_wr_cmd(0x3f);//--1/64 duty
    450c:	01000fc4 	movi	r4,63
    4510:	00043300 	call	4330 <oled_wr_cmd>
	oled_wr_cmd(0xd3);//-set display offset	Shift Mapping RAM Counter (0x00~0x3F)
    4514:	010034c4 	movi	r4,211
    4518:	00043300 	call	4330 <oled_wr_cmd>
	oled_wr_cmd(0x00);//-not offset
    451c:	0009883a 	mov	r4,zero
    4520:	00043300 	call	4330 <oled_wr_cmd>
	oled_wr_cmd(0xd5);//--set display clock divide ratio/oscillator frequency
    4524:	01003544 	movi	r4,213
    4528:	00043300 	call	4330 <oled_wr_cmd>
	oled_wr_cmd(0x80);//--set divide ratio, Set Clock as 100 Frames/Sec
    452c:	01002004 	movi	r4,128
    4530:	00043300 	call	4330 <oled_wr_cmd>
	oled_wr_cmd(0xd9);//--set pre-charge period
    4534:	01003644 	movi	r4,217
    4538:	00043300 	call	4330 <oled_wr_cmd>
	oled_wr_cmd(0xf1);//Set Pre-Charge as 15 Clocks & Discharge as 1 Clock
    453c:	01003c44 	movi	r4,241
    4540:	00043300 	call	4330 <oled_wr_cmd>
	oled_wr_cmd(0xda);//--set com pins hardware configuration
    4544:	01003684 	movi	r4,218
    4548:	00043300 	call	4330 <oled_wr_cmd>
	oled_wr_cmd(0x12);
    454c:	01000484 	movi	r4,18
    4550:	00043300 	call	4330 <oled_wr_cmd>
	oled_wr_cmd(0xdb);//--set vcomh
    4554:	010036c4 	movi	r4,219
    4558:	00043300 	call	4330 <oled_wr_cmd>
	oled_wr_cmd(0x40);//Set VCOM Deselect Level
    455c:	8809883a 	mov	r4,r17
    4560:	00043300 	call	4330 <oled_wr_cmd>
	oled_wr_cmd(0x20);//-Set Page Addressing Mode (0x00/0x01/0x02)
    4564:	01000804 	movi	r4,32
    4568:	00043300 	call	4330 <oled_wr_cmd>
	oled_wr_cmd(0x02);//
    456c:	01000084 	movi	r4,2
    4570:	00043300 	call	4330 <oled_wr_cmd>
	oled_wr_cmd(0x8d);//--set Charge Pump enable/disable
    4574:	01002344 	movi	r4,141
    4578:	00043300 	call	4330 <oled_wr_cmd>
	oled_wr_cmd(0x14);//--set(0x10) disable
    457c:	01000504 	movi	r4,20
    4580:	00043300 	call	4330 <oled_wr_cmd>
	oled_wr_cmd(0xa4);// Disable Entire Display On (0xa4/0xa5)
    4584:	01002904 	movi	r4,164
    4588:	00043300 	call	4330 <oled_wr_cmd>
	oled_wr_cmd(0xa6);// Disable Inverse Display On (0xa6/a7)
    458c:	8009883a 	mov	r4,r16
    4590:	00043300 	call	4330 <oled_wr_cmd>
	oled_wr_cmd(0xaf);//--turn on oled panel
    4594:	01002bc4 	movi	r4,175
    4598:	00043300 	call	4330 <oled_wr_cmd>
	oled_fill(0x00); //初始清屏
    459c:	0009883a 	mov	r4,zero
    45a0:	00043b80 	call	43b8 <oled_fill>
	oled_set_point(0,0);
    45a4:	0009883a 	mov	r4,zero
    45a8:	000b883a 	mov	r5,zero
}
    45ac:	dfc00217 	ldw	ra,8(sp)
    45b0:	dc400117 	ldw	r17,4(sp)
    45b4:	dc000017 	ldw	r16,0(sp)
    45b8:	dec00304 	addi	sp,sp,12
	oled_wr_cmd(0x14);//--set(0x10) disable
	oled_wr_cmd(0xa4);// Disable Entire Display On (0xa4/0xa5)
	oled_wr_cmd(0xa6);// Disable Inverse Display On (0xa6/a7)
	oled_wr_cmd(0xaf);//--turn on oled panel
	oled_fill(0x00); //初始清屏
	oled_set_point(0,0);
    45bc:	000436c1 	jmpi	436c <oled_set_point>

000045c0 <oled_show_string16>:
}

/*******************功能描述：显示8*16一组标准ASCII字符串	 显示的坐标（x,y），y为页范围0～7****************/
void oled_show_string16(alt_u8 x, alt_u8 y,char ch[])
{
    45c0:	defff504 	addi	sp,sp,-44
    45c4:	df000915 	stw	fp,36(sp)
    45c8:	ddc00815 	stw	r23,32(sp)
    45cc:	dd800715 	stw	r22,28(sp)
    45d0:	dd000515 	stw	r20,20(sp)
    45d4:	dcc00415 	stw	r19,16(sp)
    45d8:	dc400215 	stw	r17,8(sp)
    45dc:	dc000115 	stw	r16,4(sp)
    45e0:	dfc00a15 	stw	ra,40(sp)
    45e4:	dd400615 	stw	r21,24(sp)
    45e8:	dc800315 	stw	r18,12(sp)
    45ec:	302d883a 	mov	r22,r6
    45f0:	2021883a 	mov	r16,r4
    45f4:	2823883a 	mov	r17,r5
	alt_u8 c=0,i=0,j=0;
    45f8:	0027883a 	mov	r19,zero
	while (ch[j]!='\0')
	{
		c =ch[j]-32;
		if(x>120)
    45fc:	05c01e04 	movi	r23,120
	oled_fill(0x00); //初始清屏
	oled_set_point(0,0);
}

/*******************功能描述：显示8*16一组标准ASCII字符串	 显示的坐标（x,y），y为页范围0～7****************/
void oled_show_string16(alt_u8 x, alt_u8 y,char ch[])
    4600:	07000034 	movhi	fp,0
    4604:	e7152504 	addi	fp,fp,21652
		if(x>120)
		{
			x=0;y++;
		}
		oled_set_point(x,y);
		for(i=0;i<8;i++)
    4608:	05000204 	movi	r20,8

/*******************功能描述：显示8*16一组标准ASCII字符串	 显示的坐标（x,y），y为页范围0～7****************/
void oled_show_string16(alt_u8 x, alt_u8 y,char ch[])
{
	alt_u8 c=0,i=0,j=0;
	while (ch[j]!='\0')
    460c:	00002006 	br	4690 <oled_show_string16+0xd0>
	{
		c =ch[j]-32;
		if(x>120)
    4610:	80803fcc 	andi	r2,r16,255
void oled_show_string16(alt_u8 x, alt_u8 y,char ch[])
{
	alt_u8 c=0,i=0,j=0;
	while (ch[j]!='\0')
	{
		c =ch[j]-32;
    4614:	ad7ff804 	addi	r21,r21,-32
		if(x>120)
    4618:	b880022e 	bgeu	r23,r2,4624 <oled_show_string16+0x64>
		{
			x=0;y++;
    461c:	8c400044 	addi	r17,r17,1
    4620:	0021883a 	mov	r16,zero
		}
		oled_set_point(x,y);
		for(i=0;i<8;i++)
		{
			oled_wr_data(F8X16[c*16+i]);
    4624:	ad403fcc 	andi	r21,r21,255
		c =ch[j]-32;
		if(x>120)
		{
			x=0;y++;
		}
		oled_set_point(x,y);
    4628:	84803fcc 	andi	r18,r16,255
		for(i=0;i<8;i++)
		{
			oled_wr_data(F8X16[c*16+i]);
    462c:	a82a913a 	slli	r21,r21,4
		c =ch[j]-32;
		if(x>120)
		{
			x=0;y++;
		}
		oled_set_point(x,y);
    4630:	9009883a 	mov	r4,r18
    4634:	89403fcc 	andi	r5,r17,255
    4638:	000436c0 	call	436c <oled_set_point>
		for(i=0;i<8;i++)
		{
			oled_wr_data(F8X16[c*16+i]);
    463c:	0005883a 	mov	r2,zero
	oled_fill(0x00); //初始清屏
	oled_set_point(0,0);
}

/*******************功能描述：显示8*16一组标准ASCII字符串	 显示的坐标（x,y），y为页范围0～7****************/
void oled_show_string16(alt_u8 x, alt_u8 y,char ch[])
    4640:	af2b883a 	add	r21,r21,fp
    4644:	a887883a 	add	r3,r21,r2
			x=0;y++;
		}
		oled_set_point(x,y);
		for(i=0;i<8;i++)
		{
			oled_wr_data(F8X16[c*16+i]);
    4648:	19000003 	ldbu	r4,0(r3)
    464c:	d8800015 	stw	r2,0(sp)
    4650:	00042f40 	call	42f4 <oled_wr_data>
    4654:	d8800017 	ldw	r2,0(sp)
    4658:	10800044 	addi	r2,r2,1
		if(x>120)
		{
			x=0;y++;
		}
		oled_set_point(x,y);
		for(i=0;i<8;i++)
    465c:	153ff91e 	bne	r2,r20,4644 <oled_show_string16+0x84>
		{
			oled_wr_data(F8X16[c*16+i]);
		}
		oled_set_point(x,y+1);
    4660:	89400044 	addi	r5,r17,1
    4664:	9009883a 	mov	r4,r18
    4668:	29403fcc 	andi	r5,r5,255
    466c:	000436c0 	call	436c <oled_set_point>
    4670:	0025883a 	mov	r18,zero
	oled_fill(0x00); //初始清屏
	oled_set_point(0,0);
}

/*******************功能描述：显示8*16一组标准ASCII字符串	 显示的坐标（x,y），y为页范围0～7****************/
void oled_show_string16(alt_u8 x, alt_u8 y,char ch[])
    4674:	ac85883a 	add	r2,r21,r18
			oled_wr_data(F8X16[c*16+i]);
		}
		oled_set_point(x,y+1);
		for(i=0;i<8;i++)
		{
			oled_wr_data(F8X16[c*16+i+8]);
    4678:	11000203 	ldbu	r4,8(r2)
    467c:	94800044 	addi	r18,r18,1
    4680:	00042f40 	call	42f4 <oled_wr_data>
		for(i=0;i<8;i++)
		{
			oled_wr_data(F8X16[c*16+i]);
		}
		oled_set_point(x,y+1);
		for(i=0;i<8;i++)
    4684:	953ffb1e 	bne	r18,r20,4674 <oled_show_string16+0xb4>
		{
			oled_wr_data(F8X16[c*16+i+8]);
		}

		x+=8;
    4688:	84000204 	addi	r16,r16,8
		j++;
    468c:	9cc00044 	addi	r19,r19,1

/*******************功能描述：显示8*16一组标准ASCII字符串	 显示的坐标（x,y），y为页范围0～7****************/
void oled_show_string16(alt_u8 x, alt_u8 y,char ch[])
{
	alt_u8 c=0,i=0,j=0;
	while (ch[j]!='\0')
    4690:	98803fcc 	andi	r2,r19,255
    4694:	b085883a 	add	r2,r22,r2
    4698:	15400003 	ldbu	r21,0(r2)
    469c:	a8803fcc 	andi	r2,r21,255
    46a0:	1080201c 	xori	r2,r2,128
    46a4:	10bfe004 	addi	r2,r2,-128
    46a8:	103fd91e 	bne	r2,zero,4610 <oled_show_string16+0x50>
		}

		x+=8;
		j++;
	}
}
    46ac:	dfc00a17 	ldw	ra,40(sp)
    46b0:	df000917 	ldw	fp,36(sp)
    46b4:	ddc00817 	ldw	r23,32(sp)
    46b8:	dd800717 	ldw	r22,28(sp)
    46bc:	dd400617 	ldw	r21,24(sp)
    46c0:	dd000517 	ldw	r20,20(sp)
    46c4:	dcc00417 	ldw	r19,16(sp)
    46c8:	dc800317 	ldw	r18,12(sp)
    46cc:	dc400217 	ldw	r17,8(sp)
    46d0:	dc000117 	ldw	r16,4(sp)
    46d4:	dec00b04 	addi	sp,sp,44
    46d8:	f800283a 	ret

000046dc <data_show>:

void data_show(alt_u8 x,alt_u8 y,alt_u8 num)
{
    46dc:	defffa04 	addi	sp,sp,-24
    46e0:	dc800215 	stw	r18,8(sp)
    46e4:	dc400115 	stw	r17,4(sp)
    46e8:	dfc00515 	stw	ra,20(sp)
    46ec:	dd000415 	stw	r20,16(sp)
    46f0:	dcc00315 	stw	r19,12(sp)
    46f4:	dc000015 	stw	r16,0(sp)
	alt_u8 i;
	if(x>120)
    46f8:	20803fcc 	andi	r2,r4,255
    46fc:	00c01e04 	movi	r3,120
		j++;
	}
}

void data_show(alt_u8 x,alt_u8 y,alt_u8 num)
{
    4700:	2823883a 	mov	r17,r5
    4704:	3025883a 	mov	r18,r6
	alt_u8 i;
	if(x>120)
    4708:	1880022e 	bgeu	r3,r2,4714 <data_show+0x38>
	{
		x=0;y++;
    470c:	2c400044 	addi	r17,r5,1
    4710:	0009883a 	mov	r4,zero
	}
	oled_set_point(x,y);
    4714:	24c03fcc 	andi	r19,r4,255
	for(i=0;i<8;i++)
	{
		oled_wr_data(F8X16[num*16+i]);
    4718:	94803fcc 	andi	r18,r18,255
	alt_u8 i;
	if(x>120)
	{
		x=0;y++;
	}
	oled_set_point(x,y);
    471c:	9809883a 	mov	r4,r19
    4720:	89403fcc 	andi	r5,r17,255
	for(i=0;i<8;i++)
	{
		oled_wr_data(F8X16[num*16+i]);
    4724:	9024913a 	slli	r18,r18,4
	alt_u8 i;
	if(x>120)
	{
		x=0;y++;
	}
	oled_set_point(x,y);
    4728:	000436c0 	call	436c <oled_set_point>
		x+=8;
		j++;
	}
}

void data_show(alt_u8 x,alt_u8 y,alt_u8 num)
    472c:	00800034 	movhi	r2,0
    4730:	10952504 	addi	r2,r2,21652
		x=0;y++;
	}
	oled_set_point(x,y);
	for(i=0;i<8;i++)
	{
		oled_wr_data(F8X16[num*16+i]);
    4734:	0021883a 	mov	r16,zero
		x+=8;
		j++;
	}
}

void data_show(alt_u8 x,alt_u8 y,alt_u8 num)
    4738:	90a5883a 	add	r18,r18,r2
	if(x>120)
	{
		x=0;y++;
	}
	oled_set_point(x,y);
	for(i=0;i<8;i++)
    473c:	05000204 	movi	r20,8
		x+=8;
		j++;
	}
}

void data_show(alt_u8 x,alt_u8 y,alt_u8 num)
    4740:	9405883a 	add	r2,r18,r16
		x=0;y++;
	}
	oled_set_point(x,y);
	for(i=0;i<8;i++)
	{
		oled_wr_data(F8X16[num*16+i]);
    4744:	11000003 	ldbu	r4,0(r2)
    4748:	84000044 	addi	r16,r16,1
    474c:	00042f40 	call	42f4 <oled_wr_data>
	if(x>120)
	{
		x=0;y++;
	}
	oled_set_point(x,y);
	for(i=0;i<8;i++)
    4750:	853ffb1e 	bne	r16,r20,4740 <data_show+0x64>
	{
		oled_wr_data(F8X16[num*16+i]);
	}
	oled_set_point(x,y+1);
    4754:	89400044 	addi	r5,r17,1
    4758:	9809883a 	mov	r4,r19
    475c:	29403fcc 	andi	r5,r5,255
    4760:	000436c0 	call	436c <oled_set_point>
    4764:	0021883a 	mov	r16,zero
	for(i=0;i<8;i++)
    4768:	04400204 	movi	r17,8
		x+=8;
		j++;
	}
}

void data_show(alt_u8 x,alt_u8 y,alt_u8 num)
    476c:	9405883a 	add	r2,r18,r16
		oled_wr_data(F8X16[num*16+i]);
	}
	oled_set_point(x,y+1);
	for(i=0;i<8;i++)
	{
		oled_wr_data(F8X16[num*16+i+8]);
    4770:	11000203 	ldbu	r4,8(r2)
    4774:	84000044 	addi	r16,r16,1
    4778:	00042f40 	call	42f4 <oled_wr_data>
	for(i=0;i<8;i++)
	{
		oled_wr_data(F8X16[num*16+i]);
	}
	oled_set_point(x,y+1);
	for(i=0;i<8;i++)
    477c:	847ffb1e 	bne	r16,r17,476c <data_show+0x90>
	{
		oled_wr_data(F8X16[num*16+i+8]);
	}
}
    4780:	dfc00517 	ldw	ra,20(sp)
    4784:	dd000417 	ldw	r20,16(sp)
    4788:	dcc00317 	ldw	r19,12(sp)
    478c:	dc800217 	ldw	r18,8(sp)
    4790:	dc400117 	ldw	r17,4(sp)
    4794:	dc000017 	ldw	r16,0(sp)
    4798:	dec00604 	addi	sp,sp,24
    479c:	f800283a 	ret

000047a0 <oled_show_num16>:
void oled_show_num16(alt_u8 x, alt_u8 y,alt_u8 data_num)
{
    47a0:	defff704 	addi	sp,sp,-36
    47a4:	dc800215 	stw	r18,8(sp)
	alt_u8 c=0;
	alt_u8 bai,rem_bai,shi,ge;

	bai = data_num / 100;
    47a8:	34803fcc 	andi	r18,r6,255
	{
		oled_wr_data(F8X16[num*16+i+8]);
	}
}
void oled_show_num16(alt_u8 x, alt_u8 y,alt_u8 data_num)
{
    47ac:	dcc00315 	stw	r19,12(sp)
    47b0:	dc400115 	stw	r17,4(sp)
    47b4:	dc000015 	stw	r16,0(sp)
    47b8:	2027883a 	mov	r19,r4
    47bc:	2021883a 	mov	r16,r4
    47c0:	2823883a 	mov	r17,r5
	alt_u8 c=0;
	alt_u8 bai,rem_bai,shi,ge;

	bai = data_num / 100;
    47c4:	9009883a 	mov	r4,r18
    47c8:	01401904 	movi	r5,100
	{
		oled_wr_data(F8X16[num*16+i+8]);
	}
}
void oled_show_num16(alt_u8 x, alt_u8 y,alt_u8 data_num)
{
    47cc:	dfc00815 	stw	ra,32(sp)
    47d0:	ddc00715 	stw	r23,28(sp)
    47d4:	dd800615 	stw	r22,24(sp)
    47d8:	dd400515 	stw	r21,20(sp)
    47dc:	dd000415 	stw	r20,16(sp)
	alt_u8 c=0;
	alt_u8 bai,rem_bai,shi,ge;

	bai = data_num / 100;
    47e0:	0004f640 	call	4f64 <__udivsi3>
	rem_bai = data_num % 100;
    47e4:	9009883a 	mov	r4,r18
    47e8:	01401904 	movi	r5,100
void oled_show_num16(alt_u8 x, alt_u8 y,alt_u8 data_num)
{
	alt_u8 c=0;
	alt_u8 bai,rem_bai,shi,ge;

	bai = data_num / 100;
    47ec:	1029883a 	mov	r20,r2
	rem_bai = data_num % 100;
    47f0:	0004f6c0 	call	4f6c <__umodsi3>
	shi = rem_bai / 10;
    47f4:	15403fcc 	andi	r21,r2,255
    47f8:	a809883a 	mov	r4,r21
    47fc:	01400284 	movi	r5,10
    4800:	0004f640 	call	4f64 <__udivsi3>
	ge  = rem_bai % 10;
    4804:	a809883a 	mov	r4,r21
    4808:	01400284 	movi	r5,10
	alt_u8 c=0;
	alt_u8 bai,rem_bai,shi,ge;

	bai = data_num / 100;
	rem_bai = data_num % 100;
	shi = rem_bai / 10;
    480c:	1025883a 	mov	r18,r2
    4810:	102d883a 	mov	r22,r2
	ge  = rem_bai % 10;
	if(bai >0)
    4814:	a5c03fcc 	andi	r23,r20,255
	alt_u8 bai,rem_bai,shi,ge;

	bai = data_num / 100;
	rem_bai = data_num % 100;
	shi = rem_bai / 10;
	ge  = rem_bai % 10;
    4818:	0004f6c0 	call	4f6c <__umodsi3>
    481c:	102b883a 	mov	r21,r2
	if(bai >0)
    4820:	b8000626 	beq	r23,zero,483c <oled_show_num16+0x9c>
	{
		c= bai + 16;
    4824:	a1800404 	addi	r6,r20,16
		data_show(x,y,c);
    4828:	99003fcc 	andi	r4,r19,255
    482c:	89403fcc 	andi	r5,r17,255
    4830:	31803fcc 	andi	r6,r6,255
    4834:	00046dc0 	call	46dc <data_show>
		x+=8;
    4838:	9c000204 	addi	r16,r19,8
	}
	if(shi >0)
    483c:	b5803fcc 	andi	r22,r22,255
    4840:	b0000626 	beq	r22,zero,485c <oled_show_num16+0xbc>
	{
		c= shi + 16;
    4844:	91800404 	addi	r6,r18,16
		data_show(x,y,c);
    4848:	81003fcc 	andi	r4,r16,255
    484c:	89403fcc 	andi	r5,r17,255
    4850:	31803fcc 	andi	r6,r6,255
    4854:	00046dc0 	call	46dc <data_show>
		x+=8;
    4858:	84000204 	addi	r16,r16,8

	}
	if(ge >=0)
	{
		c= ge + 16;
    485c:	a9800404 	addi	r6,r21,16
		data_show(x,y,c);
    4860:	81003fcc 	andi	r4,r16,255
    4864:	89403fcc 	andi	r5,r17,255
    4868:	31803fcc 	andi	r6,r6,255
		x+=8;

	}
}
    486c:	dfc00817 	ldw	ra,32(sp)
    4870:	ddc00717 	ldw	r23,28(sp)
    4874:	dd800617 	ldw	r22,24(sp)
    4878:	dd400517 	ldw	r21,20(sp)
    487c:	dd000417 	ldw	r20,16(sp)
    4880:	dcc00317 	ldw	r19,12(sp)
    4884:	dc800217 	ldw	r18,8(sp)
    4888:	dc400117 	ldw	r17,4(sp)
    488c:	dc000017 	ldw	r16,0(sp)
    4890:	dec00904 	addi	sp,sp,36

	}
	if(ge >=0)
	{
		c= ge + 16;
		data_show(x,y,c);
    4894:	00046dc1 	jmpi	46dc <data_show>

00004898 <system_timer_isr>:
#include "alt_types.h"
alt_u32 g_timer_cnt = 0;

void system_timer_isr(void*context)
{
	g_timer_cnt ++;
    4898:	d0a00f57 	ldw	r2,-32707(gp)
    489c:	10800044 	addi	r2,r2,1
    48a0:	d0a00f55 	stw	r2,-32707(gp)

	IOWR_ALTERA_AVALON_TIMER_STATUS(SYS_TIMER_BASE,0x00);
    48a4:	00a41014 	movui	r2,36928
    48a8:	10000035 	stwio	zero,0(r2)
    48ac:	f800283a 	ret

000048b0 <get_tick_stamp>:
}

alt_u32 get_tick_stamp()
{
	return g_timer_cnt;
}
    48b0:	d0a00f57 	ldw	r2,-32707(gp)
    48b4:	f800283a 	ret

000048b8 <timer_init>:

void timer_init()
{
    48b8:	defffe04 	addi	sp,sp,-8
    48bc:	dfc00115 	stw	ra,4(sp)
	IOWR_ALTERA_AVALON_TIMER_STATUS(SYS_TIMER_BASE,0);	//清中断
    48c0:	0005883a 	mov	r2,zero
    48c4:	00e41014 	movui	r3,36928
    48c8:	18800035 	stwio	r2,0(r3)
	IOWR_ALTERA_AVALON_TIMER_PERIODL(SYS_TIMER_BASE,SYS_TIMER_LOAD_VALUE);
    48cc:	00e41214 	movui	r3,36936
    48d0:	0130d3d4 	movui	r4,49999
    48d4:	19000035 	stwio	r4,0(r3)
	IOWR_ALTERA_AVALON_TIMER_PERIODH(SYS_TIMER_BASE,SYS_TIMER_LOAD_VALUE >> 16);
    48d8:	00e41314 	movui	r3,36940
    48dc:	18800035 	stwio	r2,0(r3)
	IOWR_ALTERA_AVALON_TIMER_CONTROL(SYS_TIMER_BASE,ALTERA_AVALON_TIMER_CONTROL_ITO_MSK |	//开中断
    48e0:	00a41114 	movui	r2,36932
    48e4:	00c001c4 	movi	r3,7
    48e8:	10c00035 	stwio	r3,0(r2)
													ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |  //循环模式
													ALTERA_AVALON_TIMER_CONTROL_START_MSK); //开定时器
	alt_ic_isr_register(SYS_TIMER_IRQ_INTERRUPT_CONTROLLER_ID,	//中断注册
    48ec:	d8000015 	stw	zero,0(sp)
    48f0:	0009883a 	mov	r4,zero
    48f4:	000b883a 	mov	r5,zero
    48f8:	01800034 	movhi	r6,0
    48fc:	31922604 	addi	r6,r6,18584
    4900:	000f883a 	mov	r7,zero
    4904:	0004f740 	call	4f74 <alt_ic_isr_register>
						SYS_TIMER_IRQ,
						system_timer_isr,
						NULL,
						0x00);
}
    4908:	dfc00117 	ldw	ra,4(sp)
    490c:	dec00204 	addi	sp,sp,8
    4910:	f800283a 	ret

00004914 <get_tim_delta>:

alt_u32 get_tim_delta(alt_u32 oldTime, alt_u32 nowTime)
{
	alt_u32 timeDelta = 0;
	timeDelta = (nowTime >= oldTime )? (nowTime -oldTime):(nowTime + (0xffffffff - oldTime));
    4914:	29000236 	bltu	r5,r4,4920 <get_tim_delta+0xc>
    4918:	2905c83a 	sub	r2,r5,r4
    491c:	f800283a 	ret
    4920:	0108303a 	nor	r4,zero,r4
    4924:	2145883a 	add	r2,r4,r5
	return timeDelta;
}
    4928:	f800283a 	ret

0000492c <delay_ms>:

void delay_ms(alt_u16 ms)
{
    492c:	defffc04 	addi	sp,sp,-16
    4930:	dc400115 	stw	r17,4(sp)
	IOWR_ALTERA_AVALON_TIMER_STATUS(SYS_TIMER_BASE,0x00);
}

alt_u32 get_tick_stamp()
{
	return g_timer_cnt;
    4934:	d4600f57 	ldw	r17,-32707(gp)
	timeDelta = (nowTime >= oldTime )? (nowTime -oldTime):(nowTime + (0xffffffff - oldTime));
	return timeDelta;
}

void delay_ms(alt_u16 ms)
{
    4938:	dc000015 	stw	r16,0(sp)
    493c:	dfc00315 	stw	ra,12(sp)
    4940:	dc800215 	stw	r18,8(sp)

	do
	{
		diff = get_tim_delta(time,get_tick_stamp());
		usleep(10);
	}while(diff < ms);
    4944:	243fffcc 	andi	r16,r4,65535
	alt_u32 diff;
	time = get_tick_stamp();

	do
	{
		diff = get_tim_delta(time,get_tick_stamp());
    4948:	d1600f57 	ldw	r5,-32707(gp)
    494c:	8809883a 	mov	r4,r17
    4950:	00049140 	call	4914 <get_tim_delta>
    4954:	1025883a 	mov	r18,r2
		usleep(10);
    4958:	01000284 	movi	r4,10
    495c:	00051b80 	call	51b8 <usleep>
	}while(diff < ms);
    4960:	943ff936 	bltu	r18,r16,4948 <delay_ms+0x1c>
}
    4964:	dfc00317 	ldw	ra,12(sp)
    4968:	dc800217 	ldw	r18,8(sp)
    496c:	dc400117 	ldw	r17,4(sp)
    4970:	dc000017 	ldw	r16,0(sp)
    4974:	dec00404 	addi	sp,sp,16
    4978:	f800283a 	ret

0000497c <uart0_isr>:

alt_u8 g_rx_data;
void uart0_isr(void*context)
{
	alt_u16 rx_sta;
	rx_sta = IORD_ALTERA_AVALON_UART_STATUS(UART0_BASE);
    497c:	00a40a14 	movui	r2,36904
    4980:	10c00037 	ldwio	r3,0(r2)
	if(rx_sta & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
    4984:	18c0200c 	andi	r3,r3,128
    4988:	18000626 	beq	r3,zero,49a4 <uart0_isr+0x28>
	{
		g_rx_bit = 0;
    498c:	00c00034 	movhi	r3,0
    4990:	18d620c4 	addi	r3,r3,22659
    4994:	18000005 	stb	zero,0(r3)
		g_rx_data = IORD_ALTERA_AVALON_UART_RXDATA(UART0_BASE);
    4998:	00e40814 	movui	r3,36896
    499c:	18c00037 	ldwio	r3,0(r3)
    49a0:	d0e01045 	stb	r3,-32703(gp)
	}
	IOWR_ALTERA_AVALON_UART_STATUS(UART0_BASE,0);
    49a4:	10000035 	stwio	zero,0(r2)
    49a8:	f800283a 	ret

000049ac <uart0_init>:
}


void uart0_init()
{
    49ac:	defffe04 	addi	sp,sp,-8
    49b0:	dfc00115 	stw	ra,4(sp)
	IOWR_ALTERA_AVALON_UART_STATUS(UART0_BASE,0);	//清状态
    49b4:	0007883a 	mov	r3,zero
    49b8:	00a40a14 	movui	r2,36904
    49bc:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_AVALON_UART_CONTROL(UART0_BASE,0); //清中断
    49c0:	00a40b14 	movui	r2,36908
    49c4:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_AVALON_UART_CONTROL(UART0_BASE,ALTERA_AVALON_UART_CONTROL_RRDY_MSK); //开接收中断
    49c8:	00c02004 	movi	r3,128
    49cc:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_AVALON_UART_DIVISOR(UART0_BASE,UART0_FREQ/(UART0_BAUD + 1));
    49d0:	00a40c14 	movui	r2,36912
    49d4:	00c515c4 	movi	r3,5207
    49d8:	10c00035 	stwio	r3,0(r2)
	alt_ic_isr_register(UART0_IRQ_INTERRUPT_CONTROLLER_ID, //中断注册
    49dc:	d8000015 	stw	zero,0(sp)
    49e0:	0009883a 	mov	r4,zero
    49e4:	01400044 	movi	r5,1
    49e8:	01800034 	movhi	r6,0
    49ec:	31925f04 	addi	r6,r6,18812
    49f0:	000f883a 	mov	r7,zero
    49f4:	0004f740 	call	4f74 <alt_ic_isr_register>
						UART0_IRQ,
						uart0_isr,
						NULL,
						0x0);
}
    49f8:	dfc00117 	ldw	ra,4(sp)
    49fc:	dec00204 	addi	sp,sp,8
    4a00:	f800283a 	ret

00004a04 <main>:
#include "sys_call.h"
#include "sys_task.h"
#include "drive/inc/OLED.h"

int main()
{ 
    4a04:	deffff04 	addi	sp,sp,-4
    4a08:	dfc00015 	stw	ra,0(sp)

	timer_init();
    4a0c:	00048b80 	call	48b8 <timer_init>
	oled_init(); //OLED初始化
    4a10:	000449c0 	call	449c <oled_init>
	oled_show_string16(0,0,"CAR NUM:  220");
    4a14:	0009883a 	mov	r4,zero
    4a18:	000b883a 	mov	r5,zero
    4a1c:	01800034 	movhi	r6,0
    4a20:	31961104 	addi	r6,r6,22596
    4a24:	00045c00 	call	45c0 <oled_show_string16>
	oled_show_string16(0,2,"DISTANCE:     M");
    4a28:	0009883a 	mov	r4,zero
    4a2c:	01400084 	movi	r5,2
    4a30:	01800034 	movhi	r6,0
    4a34:	31961504 	addi	r6,r6,22612
    4a38:	00045c00 	call	45c0 <oled_show_string16>
	oled_show_string16(0,4,"TIME:       MIN");
    4a3c:	0009883a 	mov	r4,zero
    4a40:	01400104 	movi	r5,4
    4a44:	01800034 	movhi	r6,0
    4a48:	31961904 	addi	r6,r6,22628
    4a4c:	00045c00 	call	45c0 <oled_show_string16>
	uart0_init();
    4a50:	00049ac0 	call	49ac <uart0_init>
	cyc_call_cfg(CYC_CALL_CHNNL_0, CALL_POLL_500MS, led_polling);
    4a54:	0009883a 	mov	r4,zero
    4a58:	01407d04 	movi	r5,500
    4a5c:	01800034 	movhi	r6,0
    4a60:	3192e904 	addi	r6,r6,19364
    4a64:	0004a980 	call	4a98 <cyc_call_cfg>
//	cyc_call_cfg(CYC_CALL_CHNNL_1, CALL_POLL_5MS, car_polling);
	cyc_call_cfg(CYC_CALL_CHNNL_2, CALL_POLL_100MS, sure_polling);
    4a68:	01000084 	movi	r4,2
    4a6c:	01401904 	movi	r5,100
    4a70:	01800034 	movhi	r6,0
    4a74:	31931704 	addi	r6,r6,19548
    4a78:	0004a980 	call	4a98 <cyc_call_cfg>
	cyc_call_cfg(CYC_CALL_CHNNL_3, CALL_POLL_500MS, car_num_polling);
    4a7c:	010000c4 	movi	r4,3
    4a80:	01407d04 	movi	r5,500
    4a84:	01800034 	movhi	r6,0
    4a88:	31936404 	addi	r6,r6,19856
    4a8c:	0004a980 	call	4a98 <cyc_call_cfg>
//	cyc_call_cfg(CYC_CALL_CHNNL_4, CALL_POLL_5MS, speed_polling);
	while(1)
	{
		cyc_call_poll();
    4a90:	0004b540 	call	4b54 <cyc_call_poll>
    4a94:	003ffe06 	br	4a90 <main+0x8c>

00004a98 <cyc_call_cfg>:

static t_CYC_CALL_INFO m_cyc_func[CYC_CALL_FUNC_MAX];

bool cyc_call_cfg(alt_u8 idx, alt_u32 cycle, p_cycle_call_cb p_func)
{
	if ((idx >= CYC_CALL_FUNC_MAX)||(p_func == NULL) ) {
    4a98:	21003fcc 	andi	r4,r4,255
    4a9c:	00800144 	movi	r2,5
    4aa0:	11000c36 	bltu	r2,r4,4ad4 <cyc_call_cfg+0x3c>
    4aa4:	30000b26 	beq	r6,zero,4ad4 <cyc_call_cfg+0x3c>
		return false;
	}
	m_cyc_func[idx].is_open = false;
    4aa8:	2008913a 	slli	r4,r4,4
    4aac:	00c00034 	movhi	r3,0
    4ab0:	18d63904 	addi	r3,r3,22756
    4ab4:	1907883a 	add	r3,r3,r4
	m_cyc_func[idx].last_mb_stamp = 0;
    4ab8:	18800204 	addi	r2,r3,8
    4abc:	10000015 	stw	zero,0(r2)
	m_cyc_func[idx].cycle_cnt = cycle;
	m_cyc_func[idx].p_cyc_call = p_func;
	m_cyc_func[idx].is_open = true;
    4ac0:	00800044 	movi	r2,1
	if ((idx >= CYC_CALL_FUNC_MAX)||(p_func == NULL) ) {
		return false;
	}
	m_cyc_func[idx].is_open = false;
	m_cyc_func[idx].last_mb_stamp = 0;
	m_cyc_func[idx].cycle_cnt = cycle;
    4ac4:	19400115 	stw	r5,4(r3)
	m_cyc_func[idx].p_cyc_call = p_func;
    4ac8:	19800315 	stw	r6,12(r3)
	m_cyc_func[idx].is_open = true;
    4acc:	18800005 	stb	r2,0(r3)
	return true;
    4ad0:	f800283a 	ret
static t_CYC_CALL_INFO m_cyc_func[CYC_CALL_FUNC_MAX];

bool cyc_call_cfg(alt_u8 idx, alt_u32 cycle, p_cycle_call_cb p_func)
{
	if ((idx >= CYC_CALL_FUNC_MAX)||(p_func == NULL) ) {
		return false;
    4ad4:	0005883a 	mov	r2,zero
	m_cyc_func[idx].last_mb_stamp = 0;
	m_cyc_func[idx].cycle_cnt = cycle;
	m_cyc_func[idx].p_cyc_call = p_func;
	m_cyc_func[idx].is_open = true;
	return true;
}
    4ad8:	f800283a 	ret

00004adc <cyc_call_chk>:

bool cyc_call_chk(t_CYC_CALL_INFO * p_cyc)
{
    4adc:	defffd04 	addi	sp,sp,-12
    4ae0:	dc000015 	stw	r16,0(sp)
    4ae4:	dfc00215 	stw	ra,8(sp)
    4ae8:	dc400115 	stw	r17,4(sp)
    4aec:	2021883a 	mov	r16,r4
	if ( (p_cyc == NULL)||(p_cyc->p_cyc_call == NULL) ) {
    4af0:	20001226 	beq	r4,zero,4b3c <cyc_call_chk+0x60>
    4af4:	20800317 	ldw	r2,12(r4)
    4af8:	10001026 	beq	r2,zero,4b3c <cyc_call_chk+0x60>
		return false;
	}
	if (get_tim_delta(p_cyc->last_mb_stamp, get_tick_stamp()) >= p_cyc->cycle_cnt){/*更改条件为大于等于*/
    4afc:	24400217 	ldw	r17,8(r4)
    4b00:	00048b00 	call	48b0 <get_tick_stamp>
    4b04:	100b883a 	mov	r5,r2
    4b08:	8809883a 	mov	r4,r17
    4b0c:	00049140 	call	4914 <get_tim_delta>
    4b10:	80c00117 	ldw	r3,4(r16)
    4b14:	10c0012e 	bgeu	r2,r3,4b1c <cyc_call_chk+0x40>
    4b18:	00000606 	br	4b34 <cyc_call_chk+0x58>
		p_cyc->last_mb_stamp = get_tick_stamp();
    4b1c:	00048b00 	call	48b0 <get_tick_stamp>
    4b20:	80800215 	stw	r2,8(r16)
		if (p_cyc->is_open == true){
    4b24:	80800003 	ldbu	r2,0(r16)
    4b28:	10000226 	beq	r2,zero,4b34 <cyc_call_chk+0x58>
			p_cyc->p_cyc_call();
    4b2c:	80800317 	ldw	r2,12(r16)
    4b30:	103ee83a 	callr	r2
		}
	}

	return true;
    4b34:	00800044 	movi	r2,1
    4b38:	00000106 	br	4b40 <cyc_call_chk+0x64>
}

bool cyc_call_chk(t_CYC_CALL_INFO * p_cyc)
{
	if ( (p_cyc == NULL)||(p_cyc->p_cyc_call == NULL) ) {
		return false;
    4b3c:	0005883a 	mov	r2,zero
			p_cyc->p_cyc_call();
		}
	}

	return true;
}
    4b40:	dfc00217 	ldw	ra,8(sp)
    4b44:	dc400117 	ldw	r17,4(sp)
    4b48:	dc000017 	ldw	r16,0(sp)
    4b4c:	dec00304 	addi	sp,sp,12
    4b50:	f800283a 	ret

00004b54 <cyc_call_poll>:

void cyc_call_poll(void)
{
    4b54:	defffc04 	addi	sp,sp,-16
    4b58:	dc800215 	stw	r18,8(sp)
    4b5c:	dc400115 	stw	r17,4(sp)
    4b60:	dc000015 	stw	r16,0(sp)
    4b64:	dfc00315 	stw	ra,12(sp)
    4b68:	0021883a 	mov	r16,zero
	alt_u8 idx;
	for (idx = 0; idx < CYC_CALL_FUNC_MAX; idx++)
	{
		cyc_call_chk(&m_cyc_func[idx]);
    4b6c:	04800034 	movhi	r18,0
    4b70:	94963904 	addi	r18,r18,22756
}

void cyc_call_poll(void)
{
	alt_u8 idx;
	for (idx = 0; idx < CYC_CALL_FUNC_MAX; idx++)
    4b74:	04400184 	movi	r17,6
	{
		cyc_call_chk(&m_cyc_func[idx]);
    4b78:	8008913a 	slli	r4,r16,4
    4b7c:	84000044 	addi	r16,r16,1
    4b80:	9109883a 	add	r4,r18,r4
    4b84:	0004adc0 	call	4adc <cyc_call_chk>
}

void cyc_call_poll(void)
{
	alt_u8 idx;
	for (idx = 0; idx < CYC_CALL_FUNC_MAX; idx++)
    4b88:	847ffb1e 	bne	r16,r17,4b78 <cyc_call_poll+0x24>
	{
		cyc_call_chk(&m_cyc_func[idx]);
	}
}
    4b8c:	dfc00317 	ldw	ra,12(sp)
    4b90:	dc800217 	ldw	r18,8(sp)
    4b94:	dc400117 	ldw	r17,4(sp)
    4b98:	dc000017 	ldw	r16,0(sp)
    4b9c:	dec00404 	addi	sp,sp,16
    4ba0:	f800283a 	ret

00004ba4 <led_polling>:

void led_polling(void)
{
		static bool led = false;

		if(led == false)
    4ba4:	d0a01083 	ldbu	r2,-32702(gp)
    4ba8:	1000031e 	bne	r2,zero,4bb8 <led_polling+0x14>
		{
			led = true;
    4bac:	00800044 	movi	r2,1
    4bb0:	d0a01085 	stb	r2,-32702(gp)
    4bb4:	00000106 	br	4bbc <led_polling+0x18>
		}
		else
		{
			led = false;
    4bb8:	d0201085 	stb	zero,-32702(gp)
		}
		IOWR_ALTERA_AVALON_PIO_DATA(LED_BASE, led);
    4bbc:	d0e01083 	ldbu	r3,-32702(gp)
    4bc0:	00a41814 	movui	r2,36960
    4bc4:	10c00035 	stwio	r3,0(r2)
    4bc8:	f800283a 	ret

00004bcc <disp_sel>:

void disp_sel(alt_u8 num,alt_u8 sel_num)
{
	alt_u8 dat,i;
	alt_u32 gpio_sta;
	dat=code_tab[num];
    4bcc:	00800034 	movhi	r2,0
    4bd0:	10961e04 	addi	r2,r2,22648
    4bd4:	21003fcc 	andi	r4,r4,255
    4bd8:	1109883a 	add	r4,r2,r4
    4bdc:	20800003 	ldbu	r2,0(r4)
	for(i=0;i<8;i++)
	{
		IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,0x00);
    4be0:	01a40014 	movui	r6,36864

void disp_sel(alt_u8 num,alt_u8 sel_num)
{
	alt_u8 dat,i;
	alt_u32 gpio_sta;
	dat=code_tab[num];
    4be4:	01000204 	movi	r4,8
	for(i=0;i<8;i++)
	{
		IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,0x00);
    4be8:	30000035 	stwio	zero,0(r6)
		if(dat&0x80)
    4bec:	10c03fcc 	andi	r3,r2,255
    4bf0:	18c0201c 	xori	r3,r3,128
    4bf4:	18ffe004 	addi	r3,r3,-128
		{
			gpio_sta = 0x02;
    4bf8:	1806803a 	cmplt	r3,r3,zero
    4bfc:	1806907a 	slli	r3,r3,1
		else
		{
			gpio_sta = 0x00;
		}

		IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,gpio_sta);
    4c00:	30c00035 	stwio	r3,0(r6)
		gpio_sta = gpio_sta | 0x01;
    4c04:	18c00054 	ori	r3,r3,1
		IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,gpio_sta);
    4c08:	30c00035 	stwio	r3,0(r6)
    4c0c:	213fffc4 	addi	r4,r4,-1
void disp_sel(alt_u8 num,alt_u8 sel_num)
{
	alt_u8 dat,i;
	alt_u32 gpio_sta;
	dat=code_tab[num];
	for(i=0;i<8;i++)
    4c10:	20c03fcc 	andi	r3,r4,255
		}

		IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,gpio_sta);
		gpio_sta = gpio_sta | 0x01;
		IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,gpio_sta);
		dat<<=1;
    4c14:	1085883a 	add	r2,r2,r2
void disp_sel(alt_u8 num,alt_u8 sel_num)
{
	alt_u8 dat,i;
	alt_u32 gpio_sta;
	dat=code_tab[num];
	for(i=0;i<8;i++)
    4c18:	183ff31e 	bne	r3,zero,4be8 <disp_sel+0x1c>
    4c1c:	00c00204 	movi	r3,8
		dat<<=1;
	}
	dat = sel_num;
	for(i=0;i<8;i++)
	{
		IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,0x00);
    4c20:	01240014 	movui	r4,36864
    4c24:	20000035 	stwio	zero,0(r4)
		if(dat&0x80)
    4c28:	28803fcc 	andi	r2,r5,255
    4c2c:	1080201c 	xori	r2,r2,128
    4c30:	10bfe004 	addi	r2,r2,-128
		{
			gpio_sta = 0x02;
    4c34:	1004803a 	cmplt	r2,r2,zero
    4c38:	1004907a 	slli	r2,r2,1
		}
		else
		{
			gpio_sta = 0x00;
		}
		IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,gpio_sta);
    4c3c:	20800035 	stwio	r2,0(r4)
		gpio_sta = gpio_sta | 0x01;
    4c40:	10800054 	ori	r2,r2,1
		IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,gpio_sta);
    4c44:	20800035 	stwio	r2,0(r4)
    4c48:	18ffffc4 	addi	r3,r3,-1
		gpio_sta = gpio_sta | 0x01;
		IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,gpio_sta);
		dat<<=1;
	}
	dat = sel_num;
	for(i=0;i<8;i++)
    4c4c:	18803fcc 	andi	r2,r3,255
			gpio_sta = 0x00;
		}
		IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,gpio_sta);
		gpio_sta = gpio_sta | 0x01;
		IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,gpio_sta);
		dat<<=1;
    4c50:	294b883a 	add	r5,r5,r5
		gpio_sta = gpio_sta | 0x01;
		IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,gpio_sta);
		dat<<=1;
	}
	dat = sel_num;
	for(i=0;i<8;i++)
    4c54:	103ff31e 	bne	r2,zero,4c24 <disp_sel+0x58>
		IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,gpio_sta);
		gpio_sta = gpio_sta | 0x01;
		IOWR_ALTERA_AVALON_PIO_DATA(GPIO1_BASE,gpio_sta);
		dat<<=1;
	}
}
    4c58:	f800283a 	ret

00004c5c <sure_polling>:


void sure_polling(void)
{
	if(0 == g_rx_bit)
    4c5c:	d0a00003 	ldbu	r2,-32768(gp)
    4c60:	1000171e 	bne	r2,zero,4cc0 <sure_polling+0x64>
	{
		rx_table[3] = rx_table[2];
    4c64:	00800034 	movhi	r2,0
    4c68:	109621c4 	addi	r2,r2,22663
		rx_table[2] = rx_table[1];
    4c6c:	11bfffc4 	addi	r6,r2,-1

void sure_polling(void)
{
	if(0 == g_rx_bit)
	{
		rx_table[3] = rx_table[2];
    4c70:	11400003 	ldbu	r5,0(r2)
		rx_table[2] = rx_table[1];
    4c74:	31000003 	ldbu	r4,0(r6)
		rx_table[1] = rx_table[0];
    4c78:	d0e00083 	ldbu	r3,-32766(gp)

void sure_polling(void)
{
	if(0 == g_rx_bit)
	{
		rx_table[3] = rx_table[2];
    4c7c:	11400045 	stb	r5,1(r2)
		rx_table[2] = rx_table[1];
    4c80:	11000005 	stb	r4,0(r2)
		rx_table[1] = rx_table[0];
		rx_table[0] = g_rx_data;
    4c84:	00800034 	movhi	r2,0
    4c88:	10963104 	addi	r2,r2,22724
{
	if(0 == g_rx_bit)
	{
		rx_table[3] = rx_table[2];
		rx_table[2] = rx_table[1];
		rx_table[1] = rx_table[0];
    4c8c:	30c00005 	stb	r3,0(r6)
		rx_table[0] = g_rx_data;
    4c90:	11800003 	ldbu	r6,0(r2)
		g_rx_bit = 1;
    4c94:	00800044 	movi	r2,1
    4c98:	d0a00005 	stb	r2,-32768(gp)
	if(0 == g_rx_bit)
	{
		rx_table[3] = rx_table[2];
		rx_table[2] = rx_table[1];
		rx_table[1] = rx_table[0];
		rx_table[0] = g_rx_data;
    4c9c:	d1a00085 	stb	r6,-32766(gp)
		g_rx_bit = 1;
		if((rx_table[0] == 0x7f) && (rx_table[3] == 0x69))
    4ca0:	01c01fc4 	movi	r7,127
    4ca4:	31c0061e 	bne	r6,r7,4cc0 <sure_polling+0x64>
    4ca8:	29403fcc 	andi	r5,r5,255
    4cac:	01801a44 	movi	r6,105
    4cb0:	2980031e 	bne	r5,r6,4cc0 <sure_polling+0x64>
		{
			g_car_num = rx_table[2];
    4cb4:	d1200045 	stb	r4,-32767(gp)
			g_car_speed = rx_table[1];
    4cb8:	d0e01145 	stb	r3,-32699(gp)
			show_bit = 1;
    4cbc:	d0a00185 	stb	r2,-32762(gp)
    4cc0:	f800283a 	ret

00004cc4 <speed_polling>:

void speed_polling(void)
{
//	alt_u8 speed_num;
	static alt_u8 num = 0x10;
	if(0x10 == num)
    4cc4:	d16001c3 	ldbu	r5,-32761(gp)
	}

}

void speed_polling(void)
{
    4cc8:	defffe04 	addi	sp,sp,-8
    4ccc:	dc000015 	stw	r16,0(sp)
    4cd0:	dfc00115 	stw	ra,4(sp)
//	alt_u8 speed_num;
	static alt_u8 num = 0x10;
	if(0x10 == num)
    4cd4:	04000404 	movi	r16,16
    4cd8:	2c00011e 	bne	r5,r16,4ce0 <speed_polling+0x1c>
    4cdc:	00000606 	br	4cf8 <speed_polling+0x34>
	{
		disp_sel(0,num);
		num = num <<1;
	}
	else if(0x20 == num)
    4ce0:	00800804 	movi	r2,32
    4ce4:	2880021e 	bne	r5,r2,4cf0 <speed_polling+0x2c>
	{
//		speed_num = get_speed_num();
		disp_sel(g_car_speed,num);
    4ce8:	d1201143 	ldbu	r4,-32699(gp)
    4cec:	00000306 	br	4cfc <speed_polling+0x38>
		num = num <<1;
	}
	else if(0x40 == num)
    4cf0:	00801004 	movi	r2,64
    4cf4:	2880061e 	bne	r5,r2,4d10 <speed_polling+0x4c>
	{
		disp_sel(0,num);
    4cf8:	0009883a 	mov	r4,zero
    4cfc:	0004bcc0 	call	4bcc <disp_sel>
		num = num <<1;
    4d00:	d0a001c3 	ldbu	r2,-32761(gp)
    4d04:	1085883a 	add	r2,r2,r2
    4d08:	d0a001c5 	stb	r2,-32761(gp)
    4d0c:	00000306 	br	4d1c <speed_polling+0x58>
	}
	else
	{
//		speed_num = get_speed_num();
		disp_sel(g_car_speed,num);
    4d10:	d1201143 	ldbu	r4,-32699(gp)
    4d14:	0004bcc0 	call	4bcc <disp_sel>
		num = 0x10;
    4d18:	d42001c5 	stb	r16,-32761(gp)
	}
}
    4d1c:	dfc00117 	ldw	ra,4(sp)
    4d20:	dc000017 	ldw	r16,0(sp)
    4d24:	dec00204 	addi	sp,sp,8
    4d28:	f800283a 	ret

00004d2c <car_polling>:


void car_polling(void)
{
	static alt_u8 num = 1;
	if(1 == num)
    4d2c:	d1600203 	ldbu	r5,-32760(gp)
	}
}


void car_polling(void)
{
    4d30:	defffe04 	addi	sp,sp,-8
    4d34:	dc000015 	stw	r16,0(sp)
    4d38:	dfc00115 	stw	ra,4(sp)
	static alt_u8 num = 1;
	if(1 == num)
    4d3c:	04000044 	movi	r16,1
	{
		disp_sel(2,num);
    4d40:	01000084 	movi	r4,2


void car_polling(void)
{
	static alt_u8 num = 1;
	if(1 == num)
    4d44:	2c00011e 	bne	r5,r16,4d4c <car_polling+0x20>
    4d48:	00000506 	br	4d60 <car_polling+0x34>
	{
		disp_sel(2,num);
		num = num <<1;
	}
	else if(2 == num)
    4d4c:	2900021e 	bne	r5,r4,4d58 <car_polling+0x2c>
	{
		disp_sel(0,num);
    4d50:	0009883a 	mov	r4,zero
    4d54:	00000206 	br	4d60 <car_polling+0x34>
		num = num <<1;
	}
	else if(4 == num)
    4d58:	00800104 	movi	r2,4
    4d5c:	2880051e 	bne	r5,r2,4d74 <car_polling+0x48>
	{
		disp_sel(2,num);
    4d60:	0004bcc0 	call	4bcc <disp_sel>
		num = num <<1;
    4d64:	d0a00203 	ldbu	r2,-32760(gp)
    4d68:	1085883a 	add	r2,r2,r2
    4d6c:	d0a00205 	stb	r2,-32760(gp)
    4d70:	00000306 	br	4d80 <car_polling+0x54>
	}
	else
	{
		disp_sel(g_car_num,num);
    4d74:	d1200043 	ldbu	r4,-32767(gp)
    4d78:	0004bcc0 	call	4bcc <disp_sel>
		num = 1;
    4d7c:	d4200205 	stb	r16,-32760(gp)
	}
}
    4d80:	dfc00117 	ldw	ra,4(sp)
    4d84:	dc000017 	ldw	r16,0(sp)
    4d88:	dec00204 	addi	sp,sp,8
    4d8c:	f800283a 	ret

00004d90 <car_num_polling>:

void car_num_polling(void)
{
	static alt_u8 old_car_num;
	static alt_u8 old_car_speed;
	if(show_bit == 1)
    4d90:	d0a00183 	ldbu	r2,-32762(gp)
		num = 1;
	}
}

void car_num_polling(void)
{
    4d94:	deffff04 	addi	sp,sp,-4
    4d98:	dfc00015 	stw	ra,0(sp)
	static alt_u8 old_car_num;
	static alt_u8 old_car_speed;
	if(show_bit == 1)
    4d9c:	10002626 	beq	r2,zero,4e38 <car_num_polling+0xa8>
	{
		show_bit = 0;
		if(old_car_num != g_car_num)
    4da0:	d0e010c3 	ldbu	r3,-32701(gp)
    4da4:	d0a00043 	ldbu	r2,-32767(gp)
{
	static alt_u8 old_car_num;
	static alt_u8 old_car_speed;
	if(show_bit == 1)
	{
		show_bit = 0;
    4da8:	d0200185 	stb	zero,-32762(gp)
		if(old_car_num != g_car_num)
    4dac:	18800b26 	beq	r3,r2,4ddc <car_num_polling+0x4c>
		{
			oled_show_string16(104,0,"   ");
    4db0:	01001a04 	movi	r4,104
    4db4:	000b883a 	mov	r5,zero
    4db8:	01800034 	movhi	r6,0
    4dbc:	31961d04 	addi	r6,r6,22644
    4dc0:	00045c00 	call	45c0 <oled_show_string16>
			oled_show_num16(104,0,g_car_num);
    4dc4:	d1a00043 	ldbu	r6,-32767(gp)
    4dc8:	01001a04 	movi	r4,104
    4dcc:	000b883a 	mov	r5,zero
    4dd0:	00047a00 	call	47a0 <oled_show_num16>
			old_car_num = g_car_num;
    4dd4:	d0a00043 	ldbu	r2,-32767(gp)
    4dd8:	d0a010c5 	stb	r2,-32701(gp)
		}

		if(old_car_speed != g_car_speed)
    4ddc:	d0e01103 	ldbu	r3,-32700(gp)
    4de0:	d0a01143 	ldbu	r2,-32699(gp)
    4de4:	18801426 	beq	r3,r2,4e38 <car_num_polling+0xa8>
		{
			oled_show_string16(88,2,"   ");
    4de8:	01001604 	movi	r4,88
    4dec:	01400084 	movi	r5,2
    4df0:	01800034 	movhi	r6,0
    4df4:	31961d04 	addi	r6,r6,22644
    4df8:	00045c00 	call	45c0 <oled_show_string16>
			oled_show_num16(88,2,g_car_speed);
    4dfc:	d1a01143 	ldbu	r6,-32699(gp)
    4e00:	01001604 	movi	r4,88
    4e04:	01400084 	movi	r5,2
    4e08:	00047a00 	call	47a0 <oled_show_num16>
			oled_show_string16(72,4,"   ");
    4e0c:	01001204 	movi	r4,72
    4e10:	01400104 	movi	r5,4
    4e14:	01800034 	movhi	r6,0
    4e18:	31961d04 	addi	r6,r6,22644
    4e1c:	00045c00 	call	45c0 <oled_show_string16>
			oled_show_num16(72,4,g_car_speed);
    4e20:	d1a01143 	ldbu	r6,-32699(gp)
    4e24:	01001204 	movi	r4,72
    4e28:	01400104 	movi	r5,4
    4e2c:	00047a00 	call	47a0 <oled_show_num16>
			old_car_speed = g_car_speed;
    4e30:	d0a01143 	ldbu	r2,-32699(gp)
    4e34:	d0a01105 	stb	r2,-32700(gp)
		}
	}
}
    4e38:	dfc00017 	ldw	ra,0(sp)
    4e3c:	dec00104 	addi	sp,sp,4
    4e40:	f800283a 	ret

00004e44 <udivmodsi4>:
    4e44:	2005883a 	mov	r2,r4
    4e48:	2900182e 	bgeu	r5,r4,4eac <udivmodsi4+0x68>
    4e4c:	28001716 	blt	r5,zero,4eac <udivmodsi4+0x68>
    4e50:	01000804 	movi	r4,32
    4e54:	00c00044 	movi	r3,1
    4e58:	00000206 	br	4e64 <udivmodsi4+0x20>
    4e5c:	20001126 	beq	r4,zero,4ea4 <udivmodsi4+0x60>
    4e60:	28000516 	blt	r5,zero,4e78 <udivmodsi4+0x34>
    4e64:	294b883a 	add	r5,r5,r5
    4e68:	213fffc4 	addi	r4,r4,-1
    4e6c:	18c7883a 	add	r3,r3,r3
    4e70:	28bffa36 	bltu	r5,r2,4e5c <udivmodsi4+0x18>
    4e74:	18000b26 	beq	r3,zero,4ea4 <udivmodsi4+0x60>
    4e78:	0009883a 	mov	r4,zero
    4e7c:	11400236 	bltu	r2,r5,4e88 <udivmodsi4+0x44>
    4e80:	1145c83a 	sub	r2,r2,r5
    4e84:	20c8b03a 	or	r4,r4,r3
    4e88:	1806d07a 	srli	r3,r3,1
    4e8c:	280ad07a 	srli	r5,r5,1
    4e90:	183ffa1e 	bne	r3,zero,4e7c <udivmodsi4+0x38>
    4e94:	3000021e 	bne	r6,zero,4ea0 <udivmodsi4+0x5c>
    4e98:	2005883a 	mov	r2,r4
    4e9c:	f800283a 	ret
    4ea0:	f800283a 	ret
    4ea4:	0009883a 	mov	r4,zero
    4ea8:	003ffa06 	br	4e94 <udivmodsi4+0x50>
    4eac:	00c00044 	movi	r3,1
    4eb0:	0009883a 	mov	r4,zero
    4eb4:	003ff106 	br	4e7c <udivmodsi4+0x38>

00004eb8 <__divsi3>:
    4eb8:	defffe04 	addi	sp,sp,-8
    4ebc:	dfc00115 	stw	ra,4(sp)
    4ec0:	dc000015 	stw	r16,0(sp)
    4ec4:	20000a16 	blt	r4,zero,4ef0 <__divsi3+0x38>
    4ec8:	0021883a 	mov	r16,zero
    4ecc:	28000b16 	blt	r5,zero,4efc <__divsi3+0x44>
    4ed0:	000d883a 	mov	r6,zero
    4ed4:	0004e440 	call	4e44 <udivmodsi4>
    4ed8:	80000126 	beq	r16,zero,4ee0 <__divsi3+0x28>
    4edc:	0085c83a 	sub	r2,zero,r2
    4ee0:	dfc00117 	ldw	ra,4(sp)
    4ee4:	dc000017 	ldw	r16,0(sp)
    4ee8:	dec00204 	addi	sp,sp,8
    4eec:	f800283a 	ret
    4ef0:	0109c83a 	sub	r4,zero,r4
    4ef4:	04000044 	movi	r16,1
    4ef8:	283ff50e 	bge	r5,zero,4ed0 <__divsi3+0x18>
    4efc:	014bc83a 	sub	r5,zero,r5
    4f00:	8400005c 	xori	r16,r16,1
    4f04:	003ff206 	br	4ed0 <__divsi3+0x18>

00004f08 <__modsi3>:
    4f08:	deffff04 	addi	sp,sp,-4
    4f0c:	dfc00015 	stw	ra,0(sp)
    4f10:	20000516 	blt	r4,zero,4f28 <__modsi3+0x20>
    4f14:	28000c16 	blt	r5,zero,4f48 <__modsi3+0x40>
    4f18:	01800044 	movi	r6,1
    4f1c:	dfc00017 	ldw	ra,0(sp)
    4f20:	dec00104 	addi	sp,sp,4
    4f24:	0004e441 	jmpi	4e44 <udivmodsi4>
    4f28:	0109c83a 	sub	r4,zero,r4
    4f2c:	28000b16 	blt	r5,zero,4f5c <__modsi3+0x54>
    4f30:	01800044 	movi	r6,1
    4f34:	0004e440 	call	4e44 <udivmodsi4>
    4f38:	0085c83a 	sub	r2,zero,r2
    4f3c:	dfc00017 	ldw	ra,0(sp)
    4f40:	dec00104 	addi	sp,sp,4
    4f44:	f800283a 	ret
    4f48:	014bc83a 	sub	r5,zero,r5
    4f4c:	01800044 	movi	r6,1
    4f50:	dfc00017 	ldw	ra,0(sp)
    4f54:	dec00104 	addi	sp,sp,4
    4f58:	0004e441 	jmpi	4e44 <udivmodsi4>
    4f5c:	014bc83a 	sub	r5,zero,r5
    4f60:	003ff306 	br	4f30 <__modsi3+0x28>

00004f64 <__udivsi3>:
    4f64:	000d883a 	mov	r6,zero
    4f68:	0004e441 	jmpi	4e44 <udivmodsi4>

00004f6c <__umodsi3>:
    4f6c:	01800044 	movi	r6,1
    4f70:	0004e441 	jmpi	4e44 <udivmodsi4>

00004f74 <alt_ic_isr_register>:
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
    4f74:	00050101 	jmpi	5010 <alt_iic_isr_register>

00004f78 <alt_ic_irq_enable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
    4f78:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
    4f7c:	00bfff84 	movi	r2,-2
    4f80:	1884703a 	and	r2,r3,r2
    4f84:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active |= (1 << id);
    4f88:	00800034 	movhi	r2,0
    4f8c:	10963304 	addi	r2,r2,22732
    4f90:	01800044 	movi	r6,1
    4f94:	11000017 	ldw	r4,0(r2)
    4f98:	314a983a 	sll	r5,r6,r5
    4f9c:	290ab03a 	or	r5,r5,r4
    4fa0:	11400015 	stw	r5,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
    4fa4:	10800017 	ldw	r2,0(r2)
    4fa8:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
    4fac:	1801703a 	wrctl	status,r3
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_enable(irq);
}
    4fb0:	0005883a 	mov	r2,zero
    4fb4:	f800283a 	ret

00004fb8 <alt_ic_irq_disable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
    4fb8:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
    4fbc:	00bfff84 	movi	r2,-2
    4fc0:	1884703a 	and	r2,r3,r2
    4fc4:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active &= ~(1 << id);
    4fc8:	00800034 	movhi	r2,0
    4fcc:	10963304 	addi	r2,r2,22732
    4fd0:	01bfff84 	movi	r6,-2
    4fd4:	11000017 	ldw	r4,0(r2)
    4fd8:	314a183a 	rol	r5,r6,r5
    4fdc:	290a703a 	and	r5,r5,r4
    4fe0:	11400015 	stw	r5,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
    4fe4:	10800017 	ldw	r2,0(r2)
    4fe8:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
    4fec:	1801703a 	wrctl	status,r3
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_disable(irq);
}
    4ff0:	0005883a 	mov	r2,zero
    4ff4:	f800283a 	ret

00004ff8 <alt_ic_irq_enabled>:
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
    4ff8:	000530fa 	rdctl	r2,ienable

    return (irq_enabled & (1 << irq)) ? 1: 0;
    4ffc:	00c00044 	movi	r3,1
    5000:	194a983a 	sll	r5,r3,r5
    5004:	1144703a 	and	r2,r2,r5
}
    5008:	1004c03a 	cmpne	r2,r2,zero
    500c:	f800283a 	ret

00005010 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
    5010:	defffe04 	addi	sp,sp,-8
    5014:	dfc00115 	stw	ra,4(sp)
    5018:	dc000015 	stw	r16,0(sp)
  int rc = -EINVAL;  
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  alt_irq_context status;

  if (id < ALT_NIRQ)
    501c:	00c007c4 	movi	r3,31
    5020:	19401316 	blt	r3,r5,5070 <alt_iic_isr_register+0x60>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
    5024:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
    5028:	00ffff84 	movi	r3,-2
    502c:	80c6703a 	and	r3,r16,r3
    5030:	1801703a 	wrctl	status,r3
     * state.
     */

    status = alt_irq_disable_all();

    alt_irq[id].handler = isr;
    5034:	280490fa 	slli	r2,r5,3
    5038:	00c00034 	movhi	r3,0
    503c:	18d65104 	addi	r3,r3,22852
    5040:	1885883a 	add	r2,r3,r2
    5044:	11800015 	stw	r6,0(r2)
    alt_irq[id].context = isr_context;
    5048:	11c00115 	stw	r7,4(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
    504c:	30000626 	beq	r6,zero,5068 <alt_iic_isr_register+0x58>
    5050:	0004f780 	call	4f78 <alt_ic_irq_enable>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
    5054:	8001703a 	wrctl	status,r16

    alt_irq_enable_all(status);
  }

  return rc; 
}
    5058:	dfc00117 	ldw	ra,4(sp)
    505c:	dc000017 	ldw	r16,0(sp)
    5060:	dec00204 	addi	sp,sp,8
    5064:	f800283a 	ret
    status = alt_irq_disable_all();

    alt_irq[id].handler = isr;
    alt_irq[id].context = isr_context;

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
    5068:	0004fb80 	call	4fb8 <alt_ic_irq_disable>
    506c:	003ff906 	br	5054 <alt_iic_isr_register+0x44>
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  int rc = -EINVAL;  
    5070:	00bffa84 	movi	r2,-22
    5074:	003ff806 	br	5058 <alt_iic_isr_register+0x48>

00005078 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
    5078:	deffff04 	addi	sp,sp,-4
    507c:	dfc00015 	stw	ra,0(sp)

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
    5080:	01400034 	movhi	r5,0
    5084:	29561e04 	addi	r5,r5,22648
    5088:	01800034 	movhi	r6,0
    508c:	31962704 	addi	r6,r6,22684
    5090:	29801026 	beq	r5,r6,50d4 <alt_load+0x5c>
  {
    while( to != end )
    5094:	00800034 	movhi	r2,0
    5098:	10962704 	addi	r2,r2,22684
    509c:	28800d26 	beq	r5,r2,50d4 <alt_load+0x5c>
 * alt_load() is called when the code is executing from flash. In this case
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
    50a0:	29c00104 	addi	r7,r5,4
    50a4:	11cfc83a 	sub	r7,r2,r7
    50a8:	380ed0ba 	srli	r7,r7,2
    50ac:	0005883a 	mov	r2,zero
    50b0:	39c00044 	addi	r7,r7,1
    50b4:	39cf883a 	add	r7,r7,r7
    50b8:	39cf883a 	add	r7,r7,r7
    50bc:	3087883a 	add	r3,r6,r2
    {
      *to++ = *from++;
    50c0:	19000017 	ldw	r4,0(r3)
    50c4:	2887883a 	add	r3,r5,r2
    50c8:	10800104 	addi	r2,r2,4
    50cc:	19000015 	stw	r4,0(r3)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
    50d0:	11fffa1e 	bne	r2,r7,50bc <alt_load+0x44>

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
    50d4:	01400034 	movhi	r5,0
    50d8:	29500804 	addi	r5,r5,16416
    50dc:	01800034 	movhi	r6,0
    50e0:	31900804 	addi	r6,r6,16416
    50e4:	29801026 	beq	r5,r6,5128 <alt_load+0xb0>
  {
    while( to != end )
    50e8:	00800034 	movhi	r2,0
    50ec:	10905404 	addi	r2,r2,16720
    50f0:	28800d26 	beq	r5,r2,5128 <alt_load+0xb0>
    50f4:	29c00104 	addi	r7,r5,4
    50f8:	11cfc83a 	sub	r7,r2,r7
    50fc:	380ed0ba 	srli	r7,r7,2
    5100:	0005883a 	mov	r2,zero
    5104:	39c00044 	addi	r7,r7,1
    5108:	39cf883a 	add	r7,r7,r7
    510c:	39cf883a 	add	r7,r7,r7
    5110:	3087883a 	add	r3,r6,r2
    {
      *to++ = *from++;
    5114:	19000017 	ldw	r4,0(r3)
    5118:	2887883a 	add	r3,r5,r2
    511c:	10800104 	addi	r2,r2,4
    5120:	19000015 	stw	r4,0(r3)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
    5124:	11fffa1e 	bne	r2,r7,5110 <alt_load+0x98>

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
    5128:	01400034 	movhi	r5,0
    512c:	29552504 	addi	r5,r5,21652
    5130:	01800034 	movhi	r6,0
    5134:	31952504 	addi	r6,r6,21652
    5138:	29801026 	beq	r5,r6,517c <alt_load+0x104>
  {
    while( to != end )
    513c:	00800034 	movhi	r2,0
    5140:	10961e04 	addi	r2,r2,22648
    5144:	28800d26 	beq	r5,r2,517c <alt_load+0x104>
    5148:	29c00104 	addi	r7,r5,4
    514c:	11cfc83a 	sub	r7,r2,r7
    5150:	380ed0ba 	srli	r7,r7,2
    5154:	0005883a 	mov	r2,zero
    5158:	39c00044 	addi	r7,r7,1
    515c:	39cf883a 	add	r7,r7,r7
    5160:	39cf883a 	add	r7,r7,r7
    5164:	3087883a 	add	r3,r6,r2
    {
      *to++ = *from++;
    5168:	19000017 	ldw	r4,0(r3)
    516c:	2887883a 	add	r3,r5,r2
    5170:	10800104 	addi	r2,r2,4
    5174:	19000015 	stw	r4,0(r3)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
    5178:	11fffa1e 	bne	r2,r7,5164 <alt_load+0xec>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
    517c:	00053040 	call	5304 <alt_dcache_flush_all>
  alt_icache_flush_all();
}
    5180:	dfc00017 	ldw	ra,0(sp)
    5184:	dec00104 	addi	sp,sp,4
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  alt_icache_flush_all();
    5188:	00053081 	jmpi	5308 <alt_icache_flush_all>

0000518c <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
    518c:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
    5190:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
    5194:	dfc00015 	stw	ra,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
    5198:	00051bc0 	call	51bc <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
    519c:	00051dc0 	call	51dc <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
    51a0:	d1201557 	ldw	r4,-32683(gp)
    51a4:	d1601457 	ldw	r5,-32687(gp)
    51a8:	d1a01357 	ldw	r6,-32691(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
    51ac:	dfc00017 	ldw	ra,0(sp)
    51b0:	dec00104 	addi	sp,sp,4
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
    51b4:	0004a041 	jmpi	4a04 <main>

000051b8 <usleep>:
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
  return alt_busy_sleep(us);
    51b8:	000527c1 	jmpi	527c <alt_busy_sleep>

000051bc <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
    51bc:	deffff04 	addi	sp,sp,-4
    51c0:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( SYS_NIOS, sys_nios);
    51c4:	000543c0 	call	543c <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
    51c8:	00800044 	movi	r2,1
    51cc:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
    51d0:	dfc00017 	ldw	ra,0(sp)
    51d4:	dec00104 	addi	sp,sp,4
    51d8:	f800283a 	ret

000051dc <alt_sys_init>:
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
    ALTERA_AVALON_TIMER_INIT ( SYS_TIMER, sys_timer);
    51dc:	01241014 	movui	r4,36928
    51e0:	000b883a 	mov	r5,zero
    51e4:	000d883a 	mov	r6,zero
    51e8:	01c0fa04 	movi	r7,1000
    51ec:	000522c1 	jmpi	522c <alt_avalon_timer_sc_init>

000051f0 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
    51f0:	defffe04 	addi	sp,sp,-8
    51f4:	dfc00115 	stw	ra,4(sp)
    51f8:	dc000015 	stw	r16,0(sp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
    51fc:	20000035 	stwio	zero,0(r4)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
    5200:	20800137 	ldwio	r2,4(r4)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
    5204:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
    5208:	00bfff84 	movi	r2,-2
    520c:	8084703a 	and	r2,r16,r2
    5210:	1001703a 	wrctl	status,r2
  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
  alt_tick ();
    5214:	00053480 	call	5348 <alt_tick>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
    5218:	8001703a 	wrctl	status,r16
  alt_irq_enable_all(cpu_sr);
}
    521c:	dfc00117 	ldw	ra,4(sp)
    5220:	dc000017 	ldw	r16,0(sp)
    5224:	dec00204 	addi	sp,sp,8
    5228:	f800283a 	ret

0000522c <alt_avalon_timer_sc_init>:
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
    522c:	00c00034 	movhi	r3,0
    5230:	18d63804 	addi	r3,r3,22752
    5234:	1a000017 	ldw	r8,0(r3)
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
    5238:	defffe04 	addi	sp,sp,-8
    523c:	dfc00115 	stw	ra,4(sp)
    5240:	2005883a 	mov	r2,r4
    5244:	2809883a 	mov	r4,r5
    5248:	300b883a 	mov	r5,r6
    524c:	4000011e 	bne	r8,zero,5254 <alt_avalon_timer_sc_init+0x28>
  {
    _alt_tick_rate = nticks;
    5250:	19c00015 	stw	r7,0(r3)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
    5254:	00c001c4 	movi	r3,7
    5258:	10c00135 	stwio	r3,4(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
    525c:	d8000015 	stw	zero,0(sp)
    5260:	01800034 	movhi	r6,0
    5264:	31947c04 	addi	r6,r6,20976
    5268:	100f883a 	mov	r7,r2
    526c:	0004f740 	call	4f74 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
    5270:	dfc00117 	ldw	ra,4(sp)
    5274:	dec00204 	addi	sp,sp,8
    5278:	f800283a 	ret

0000527c <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
    527c:	defffe04 	addi	sp,sp,-8
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
    5280:	01420034 	movhi	r5,2048
    5284:	297fffc4 	addi	r5,r5,-1
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
    5288:	dc000015 	stw	r16,0(sp)
    528c:	dfc00115 	stw	ra,4(sp)
    5290:	2021883a 	mov	r16,r4
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
    5294:	0004f640 	call	4f64 <__udivsi3>
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
    5298:	10001226 	beq	r2,zero,52e4 <alt_busy_sleep+0x68>
    529c:	0007883a 	mov	r3,zero
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
    52a0:	01600034 	movhi	r5,32768
    52a4:	297fffc4 	addi	r5,r5,-1
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
    52a8:	013e0034 	movhi	r4,63488
    52ac:	21000044 	addi	r4,r4,1
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
    52b0:	297fffc4 	addi	r5,r5,-1
    52b4:	283ffe1e 	bne	r5,zero,52b0 <alt_busy_sleep+0x34>
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
    52b8:	18c00044 	addi	r3,r3,1
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
    52bc:	8121883a 	add	r16,r16,r4
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
    52c0:	18bffb16 	blt	r3,r2,52b0 <alt_busy_sleep+0x34>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
    52c4:	8020913a 	slli	r16,r16,4
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
    52c8:	843fffc4 	addi	r16,r16,-1
    52cc:	803ffe1e 	bne	r16,zero,52c8 <alt_busy_sleep+0x4c>
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
}
    52d0:	0005883a 	mov	r2,zero
    52d4:	dfc00117 	ldw	ra,4(sp)
    52d8:	dc000017 	ldw	r16,0(sp)
    52dc:	dec00204 	addi	sp,sp,8
    52e0:	f800283a 	ret
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
    52e4:	8020913a 	slli	r16,r16,4
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
    52e8:	843fffc4 	addi	r16,r16,-1
    52ec:	043ffe16 	blt	zero,r16,52e8 <alt_busy_sleep+0x6c>
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
}
    52f0:	0005883a 	mov	r2,zero
    52f4:	dfc00117 	ldw	ra,4(sp)
    52f8:	dc000017 	ldw	r16,0(sp)
    52fc:	dec00204 	addi	sp,sp,8
    5300:	f800283a 	ret

00005304 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
    5304:	f800283a 	ret

00005308 <alt_icache_flush_all>:
 */

void alt_icache_flush_all (void)
{
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
    5308:	0009883a 	mov	r4,zero
    530c:	01440004 	movi	r5,4096
    5310:	00054441 	jmpi	5444 <alt_icache_flush>

00005314 <alt_alarm_stop>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
    5314:	0005303a 	rdctl	r2,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
    5318:	00ffff84 	movi	r3,-2
    531c:	10c6703a 	and	r3,r2,r3
    5320:	1801703a 	wrctl	status,r3
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
    5324:	20c00017 	ldw	r3,0(r4)
    5328:	21400117 	ldw	r5,4(r4)
    532c:	19400115 	stw	r5,4(r3)
  entry->previous->next = entry->next;
    5330:	21400117 	ldw	r5,4(r4)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
    5334:	21000115 	stw	r4,4(r4)
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
  entry->previous->next = entry->next;
    5338:	28c00015 	stw	r3,0(r5)
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
  entry->next     = entry;
    533c:	21000015 	stw	r4,0(r4)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
    5340:	1001703a 	wrctl	status,r2
    5344:	f800283a 	ret

00005348 <alt_tick>:

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
    5348:	d0a01657 	ldw	r2,-32679(gp)
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
    534c:	defffa04 	addi	sp,sp,-24
    5350:	dc000015 	stw	r16,0(sp)
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
    5354:	d4200457 	ldw	r16,-32751(gp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
    5358:	10800044 	addi	r2,r2,1
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
    535c:	dc800215 	stw	r18,8(sp)
    5360:	dfc00515 	stw	ra,20(sp)
    5364:	dd000415 	stw	r20,16(sp)
    5368:	dcc00315 	stw	r19,12(sp)
    536c:	dc400115 	stw	r17,4(sp)
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
    5370:	d4a00444 	addi	r18,gp,-32751

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
    5374:	d0a01655 	stw	r2,-32679(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
    5378:	84801c26 	beq	r16,r18,53ec <alt_tick+0xa4>
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
        {
          alarm->rollover = 1;
    537c:	04c00044 	movi	r19,1
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
    5380:	053fff84 	movi	r20,-2
    5384:	00000206 	br	5390 <alt_tick+0x48>
    5388:	8821883a 	mov	r16,r17

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
    538c:	8c801726 	beq	r17,r18,53ec <alt_tick+0xa4>
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
    5390:	80800403 	ldbu	r2,16(r16)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  {
    next = (alt_alarm*) alarm->llist.next;
    5394:	84400017 	ldw	r17,0(r16)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
    5398:	10000326 	beq	r2,zero,53a8 <alt_tick+0x60>
    539c:	d0a01657 	ldw	r2,-32679(gp)
    53a0:	1000011e 	bne	r2,zero,53a8 <alt_tick+0x60>
    {
      alarm->rollover = 0;
    53a4:	80000405 	stb	zero,16(r16)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
    53a8:	d0e01657 	ldw	r3,-32679(gp)
    53ac:	80800217 	ldw	r2,8(r16)
    53b0:	18bff536 	bltu	r3,r2,5388 <alt_tick+0x40>
    53b4:	80800403 	ldbu	r2,16(r16)
    53b8:	103ff31e 	bne	r2,zero,5388 <alt_tick+0x40>
    {
      next_callback = alarm->callback (alarm->context);
    53bc:	80800317 	ldw	r2,12(r16)
    53c0:	81000517 	ldw	r4,20(r16)
    53c4:	103ee83a 	callr	r2

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
    53c8:	10001026 	beq	r2,zero,540c <alt_tick+0xc4>
      {
        alt_alarm_stop (alarm);
      }
      else
      {
        alarm->time += next_callback;
    53cc:	81000217 	ldw	r4,8(r16)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
    53d0:	d0e01657 	ldw	r3,-32679(gp)
      {
        alt_alarm_stop (alarm);
      }
      else
      {
        alarm->time += next_callback;
    53d4:	1105883a 	add	r2,r2,r4
    53d8:	80800215 	stw	r2,8(r16)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
    53dc:	10ffea2e 	bgeu	r2,r3,5388 <alt_tick+0x40>
        {
          alarm->rollover = 1;
    53e0:	84c00405 	stb	r19,16(r16)
    53e4:	8821883a 	mov	r16,r17

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
    53e8:	8cbfe91e 	bne	r17,r18,5390 <alt_tick+0x48>
  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
}
    53ec:	dfc00517 	ldw	ra,20(sp)
    53f0:	dd000417 	ldw	r20,16(sp)
    53f4:	dcc00317 	ldw	r19,12(sp)
    53f8:	dc800217 	ldw	r18,8(sp)
    53fc:	dc400117 	ldw	r17,4(sp)
    5400:	dc000017 	ldw	r16,0(sp)
    5404:	dec00604 	addi	sp,sp,24
    5408:	f800283a 	ret
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
    540c:	0005303a 	rdctl	r2,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
    5410:	1506703a 	and	r3,r2,r20
    5414:	1801703a 	wrctl	status,r3
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
    5418:	80c00017 	ldw	r3,0(r16)
    541c:	81000117 	ldw	r4,4(r16)
    5420:	19000115 	stw	r4,4(r3)
  entry->previous->next = entry->next;
    5424:	81000117 	ldw	r4,4(r16)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
    5428:	84000115 	stw	r16,4(r16)
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
  entry->previous->next = entry->next;
    542c:	20c00015 	stw	r3,0(r4)
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
  entry->next     = entry;
    5430:	84000015 	stw	r16,0(r16)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
    5434:	1001703a 	wrctl	status,r2
    5438:	003fd306 	br	5388 <alt_tick+0x40>

0000543c <altera_nios2_qsys_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
    543c:	000170fa 	wrctl	ienable,zero
    5440:	f800283a 	ret

00005444 <alt_icache_flush>:
  if (len > NIOS2_ICACHE_SIZE)
  {
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;
    5444:	00840004 	movi	r2,4096
    5448:	1140012e 	bgeu	r2,r5,5450 <alt_icache_flush+0xc>
    544c:	100b883a 	mov	r5,r2
    5450:	214b883a 	add	r5,r4,r5

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
    5454:	2005883a 	mov	r2,r4
    5458:	2140092e 	bgeu	r4,r5,5480 <alt_icache_flush+0x3c>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
    545c:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
    5460:	10800804 	addi	r2,r2,32
    5464:	117ffd36 	bltu	r2,r5,545c <alt_icache_flush+0x18>
/*
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
    5468:	0104303a 	nor	r2,zero,r4
    546c:	2885883a 	add	r2,r5,r2
    5470:	1004d17a 	srli	r2,r2,5
    5474:	10800044 	addi	r2,r2,1
    5478:	1004917a 	slli	r2,r2,5
    547c:	2085883a 	add	r2,r4,r2
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
    5480:	210007cc 	andi	r4,r4,31
    5484:	20000126 	beq	r4,zero,548c <alt_icache_flush+0x48>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
    5488:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
    548c:	0000203a 	flushp
    5490:	f800283a 	ret
